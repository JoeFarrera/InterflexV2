package es.sysmap.interflex.model.bdc;
import es.sysmap.interflex.model.dmc.SgaposicionubicacionViewRowImpl;
import es.sysmap.interflex.model.dmc.SgavubicacionlibresloViewRowImpl;
import es.sysmap.xml.XMLTelegrama;
import java.util.Vector;
import oracle.jbo.Row;
import oracle.jbo.ViewObject;
import oracle.jbo.server.DBTransaction;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.domain.Number;
import oracle.jbo.Key;
import oracle.jbo.RowIterator;
import oracle.jbo.server.SequenceImpl;
import oracle.xml.parser.v2.XMLNode;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------

public class SgaubicacionSiloImpl extends SgaubicacionImpl 
{
  public static final int MAXATTRCONST = EntityDefImpl.getMaxAttrConst("es.sysmap.interflex.model.bdc.Sgaubicacion");
  public static final int PASILLO = MAXATTRCONST;
  public static final int COLUMNA = MAXATTRCONST + 1;
  public static final int NIVEL = MAXATTRCONST + 2;
  public static final int LADO = MAXATTRCONST + 3;
  public static final int ROTACION = MAXATTRCONST + 4;
  public static final int POSPLC = MAXATTRCONST + 5;
  public static final int SGAPASILLOENTSAL = MAXATTRCONST + 6;
  public static final int SGAPUESTOMANIPMLD = MAXATTRCONST + 7;
  public static final int SGAPUESTOMANIPSLO = MAXATTRCONST + 8;
  public static final int ESTADO = MAXATTRCONST + 5;



  private static final int LIBERAR = 0;
  private static final int OCUPAR = 1;
  private static final int RESERVAR = 2;
  private static final int QUITARRESERVA = 3;
  private static final int INSPECCIONAR = 4;
  private static final int QUITARINSPECCIONAR = 5;
  
  // Comprometiendo la reubicación del package de estas vistas... 
  private static String VUBICACIONLIBRESILO  = "es.sysmap.interflex.model.dmc.SgavubicacionlibresloView";
  






  private static SgaubicacionDefImpl mDefinitionObject;

  /**
   * 
   *  This is the default constructor (do not remove)
   */
  public SgaubicacionSiloImpl()
  {
  }

  /**
   * 
   *  Retrieves the definition object for this instance class.
   */
  public static synchronized EntityDefImpl getDefinitionObject()
  {
    if (mDefinitionObject == null)
    {
      mDefinitionObject = (SgaubicacionDefImpl)EntityDefImpl.findDefObject("es.sysmap.interflex.model.bdc.SgaubicacionSilo");
    }
    return mDefinitionObject;
  }







  /**
   * 
   *  Gets the attribute value for Pasillo, using the alias name Pasillo
   */
  public Number getPasillo()
  {
    return (Number)getAttributeInternal(PASILLO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Pasillo
   */
  public void setPasillo(Number value)
  {
    setAttributeInternal(PASILLO, value);
  }

  /**
   * 
   *  Gets the attribute value for Columna, using the alias name Columna
   */
  public Number getColumna()
  {
    return (Number)getAttributeInternal(COLUMNA);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Columna
   */
  public void setColumna(Number value)
  {
    setAttributeInternal(COLUMNA, value);
  }

  /**
   * 
   *  Gets the attribute value for Nivel, using the alias name Nivel
   */
  public Number getNivel()
  {
    return (Number)getAttributeInternal(NIVEL);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Nivel
   */
  public void setNivel(Number value)
  {
    setAttributeInternal(NIVEL, value);
  }

  /**
   * 
   *  Gets the attribute value for Lado, using the alias name Lado
   */
  public String getLado()
  {
    return (String)getAttributeInternal(LADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Lado
   */
  public void setLado(String value)
  {
    setAttributeInternal(LADO, value);
  }

  /**
   * 
   *  Gets the attribute value for Rotacion, using the alias name Rotacion
   */
  public String getRotacion()
  {
    return (String)getAttributeInternal(ROTACION);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Rotacion
   */
  public void setRotacion(String value)
  {
    setAttributeInternal(ROTACION, value);
  }

  /**
   * 
   *  Gets the attribute value for Estado, using the alias name Estado
   */
  public String getEstado()
  {
    return (String)getAttributeInternal(ESTADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Estado
   */
  public void setEstado(String value)
  {
    setAttributeInternal(ESTADO, value);
  }

  /**
   * 
   *  getAttrInvokeAccessor: generated method. Do not modify.
   */
  protected Object getAttrInvokeAccessor(int index, AttributeDefImpl attrDef) throws Exception
  {
    if (index == PASILLO)
    {
      return getPasillo();
    }
    if (index == COLUMNA)
    {
      return getColumna();
    }
    if (index == NIVEL)
    {
      return getNivel();
    }
    if (index == LADO)
    {
      return getLado();
    }
    if (index == ROTACION)
    {
      return getRotacion();
    }
    if (index == IDTIPALM)
    {
      return getIdtipalm();
    }
    if (index == POSPLC)
    {
      return getPosplc();
    }
    if (index == SGAPUESTOMANIPMLD)
    {
      return getSgapuestomanipMld();
    }
    if (index == SGAPUESTOMANIPSLO)
    {
      return getSgapuestomanipSlo();
    }
    if (index == SGAPASILLOENTSAL)
    {
      return getSgapasilloEntSal();
    }
    return super.getAttrInvokeAccessor(index, attrDef);
  }

  /**
   * 
   *  setAttrInvokeAccessor: generated method. Do not modify.
   */
  protected void setAttrInvokeAccessor(int index, Object value, AttributeDefImpl attrDef) throws Exception
  {
    if (index == PASILLO)
    {
      setPasillo((Number)value);
      return;
    }
    if (index == COLUMNA)
    {
      setColumna((Number)value);
      return;
    }
    if (index == NIVEL)
    {
      setNivel((Number)value);
      return;
    }
    if (index == LADO)
    {
      setLado((String)value);
      return;
    }
    if (index == ROTACION)
    {
      setRotacion((String)value);
      return;
    }
    if (index == POSPLC)
    {
      setPosplc((Number)value);
      return;
    }
    super.setAttrInvokeAccessor(index, value, attrDef);
    return;
  }



  /**
   * 
   *  Gets the attribute value for Idtipalm, using the alias name Idtipalm
   */
  public String getIdtipalm()
  {
    return super.getIdtipalm();
  }




  public String getTipoAlmacen()
  {
    return ("Silo");
  }

 public void liberarUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    updatePosiciones(LIBERAR, posicion, numPos);
  }

  public void ocuparUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    updatePosiciones(OCUPAR, posicion, numPos);
  }

  private void updatePosicion (int accion, SgaposicionubicacionImpl posicion)
  {
    switch (accion)
      {
        case LIBERAR:
          posicion.liberarPosicion();
          break;
        case RESERVAR:
          posicion.reservarPosicion();
          break;
        case OCUPAR:
          posicion.ocuparPosicion();
          break;
        case QUITARRESERVA:
          posicion.quitarReservaPosicion();
          break;
        case INSPECCIONAR:
          posicion.setPendienteInspeccionPosicion();
          break;
        case QUITARINSPECCIONAR:
          posicion.anularPendienteInspeccionPosicion();
          break;

      }
 }

  /**
   * Actualizar el número de posiciones que ocupará el mac
   * @param numPos Número de posiciones a ocupar
   * @param posicion  Posicion Inicial
   * @param accion accion a realizar
   */
  private void updatePosiciones (int accion, SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
    {
      if (numPos != null && numPos.intValue() > 1)
      {
        // hay que reservar más de una posición
        int posIni = posicion.getPosicion().intValue();
        int posFin = posIni + numPos.intValue() - 1;
        RowIterator rows = getSgaposicionubicacion();
        while (rows.hasNext())
        {
          SgaposicionubicacionImpl row = (SgaposicionubicacionImpl)rows.next();
          int curPos = row.getPosicion().intValue();
          if (curPos >= posIni && curPos <= posFin)
          {
            updatePosicion (accion, row);
          }
        }
      }
      else
        updatePosicion (accion, posicion);
    }
  }
  
  
  public void reservarUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    updatePosiciones(RESERVAR, posicion, numPos);
  }
  
  public void quitarReservaUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    updatePosiciones(QUITARRESERVA, posicion, numPos);
  }


  public void setPendienteInspeccion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    updatePosiciones(INSPECCIONAR, posicion, numPos);
  }











  /**
   * Confeccionar el nodo XML correspondiente a la ubicación
   * @return 
   * @param node
   */
  public XMLNode getXMLUbicacion(XMLNode node)
  {
  try 
  {
    node.getFirstChild().setNodeValue(getPosplc().toString());
    XMLTelegrama.setValorNodo(node,"lado",getLado());
    XMLTelegrama.setValorNodo(node,"columna", getColumna().toString());
    XMLTelegrama.setValorNodo(node,"nivel", getNivel().toString());
  } catch (Exception ex) 
  {
    LOG.error("getXMLUbicacion",ex);
  } 
    return node;
  }
  
   public XMLNode getXMLUbicacionSiguiente(XMLNode node, SgaposicionubicacionImpl posUbiDes)
   {
     SgaubicacionImpl ubiDes = posUbiDes.getSgaubicacion();
     if (getPosplc().equals(ubiDes.getPosplc()))
     {
        // Es una reubicación en el mismo pasillo
        node = posUbiDes.getXMLPosicion(node);
     }
     else
     {
        // Solo puede ser una reubicación de un pasillo a otro, ya que el destino lleva posición
        // :TODO 14.04.2005 Comprobar que realmente se puede enviar la entrada al otro pasillo como destino
        node = posUbiDes.getXMLPosicionEntrada(node);
     }
    return (node);
   }
  
    /**
   * 
   * @return el nodo XML correspondiente al siguiente destino desde esta posición
   * Para el silo, será la mesa de salida del pasillo
   * :TODO 24.03.2005 En la entrada del extra se envia la paleta a la 27 en vez de la unicación.
   * @param ubiDes
   * @param node
   */
  public XMLNode getXMLUbicacionSiguiente(XMLNode node, SgaubicacionImpl ubiDes)
  {
    if (getPosplc().equals(ubiDes.getPosplc()))
    {
      // Es una reubicación en el mismo pasillo
      node = ubiDes.getXMLUbicacion(node);
    }
    else if (getSgapasilloEntSal().getidPasillo().intValue() == PASILLO_1 && ubiDes.getPosplc().intValue() == POSPLC_ENTRADA_EXTRA)
    {
      // Estamos en el pasillo 1 y es una salida por la extra
      node = ubiDes.getXMLUbicacion(node);
    }
    else
    {
      // Es una salida del pasillo, primero a la mesa de salida del pasillo
    //  int pasillo = getPasillo();
      node = getSgapasilloEntSal().getXMLSalidaPasillo(node);
    }
    
    return node;
  }

  /**
   * 
   * @return el nodo XML correspondiente a la entrada del pasillo
   * @param ubiDes
   * @param node
   */
  public XMLNode getXMLUbicacionEntrada(XMLNode node)
  {
    return getSgapasilloEntSal().getXMLEntradaPasillo(node);
  }


  /**
   * 
   *  Gets the attribute value for Posplc, using the alias name Posplc
   */
  public Number getPosplc()
  {
    return (Number)getAttributeInternal(POSPLC);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Posplc
   */
  public void setPosplc(Number value)
  {
    setAttributeInternal(POSPLC, value);
  }


  public String getDescripvisual()
  {
    String magatzem = /* getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Idtipalm")).getLabel(null)  + ": " +  */ this.getIdtipalm();
    String passadis = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Pasillo")).getLabel(null)  + ": " +  this.getPasillo();
    String costat = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Lado")).getLabel(null) + ": " + this.getLado();
    String columna = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Columna")).getLabel(null) + ": " + this.getColumna();
    String nivell = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Nivel")).getLabel(null) + ": " + this.getNivel();
    
    return  magatzem + " " + passadis + " " + costat + " " + columna + " " + nivell;
  }


  /**
   * Buscar otra ubicación libre en el pasillo para el mismo tipo de mac como consecuencia de un error de deposito
   * @return la posición encontrado o null si no hay más huecos disponibles
   * @param idTipmac
   * @param posicion posicion actual del mac
   */
  public SgaposicionubicacionImpl getPosicionUbicacionErrorDeposito(String idTipmac, SgaposicionubicacionImpl posicion)
  {
      DBTransaction txn = getDBTransaction();
      ViewObject vo = txn.createViewObject(VUBICACIONLIBRESILO);
      vo.setWhereClauseParam(0,idTipmac);
      vo.setWhereClauseParam(1, getPasillo());
      vo.executeQuery();
      vo.reset();
      while (vo.hasNext())
      {
        SgavubicacionlibresloViewRowImpl row = (SgavubicacionlibresloViewRowImpl)vo.next();
        SgaposicionubicacionViewRowImpl viewRow = (SgaposicionubicacionViewRowImpl)row.getSgaposicionubicacionView();
        SgaposicionubicacionImpl posUbi = viewRow.getSgaposicionubicacion();
        // Pero que no sea este, claro
        if (posUbi.getIdubi().equals(getIdubi()) && posUbi.getPosicion().equals(posicion.getPosicion()))
          continue;
        vo.remove();
        return posUbi;
      }
      return null;  // No ha encontrado nada
  }

  /**
   * 
   *  Gets the associated entity SgapasilloImpl
   */
  public SgapasilloImpl getSgapasilloEntSal()
  {
    return (SgapasilloImpl)getAttributeInternal(SGAPASILLOENTSAL);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgapasilloImpl
   */
  public void setSgapasilloEntSal(SgapasilloImpl value)
  {
    setAttributeInternal(SGAPASILLOENTSAL, value);
  }




  public void getDisponibilitat(SgaposicionubicacionImpl posicioUbicacio, Vector disponibilitat)
  {
    //Mirem que el passadis estigui disponible
    getSgapasilloEntSal().getDisponibilitat(disponibilitat);
    //Mirem que la possició estigui disponible
    posicioUbicacio.getDisponibilitatOcupada(disponibilitat);
  }

  /**
   * 
   *  Gets the associated entity SgapuestomanipImpl
   */
  public SgapuestomanipImpl getSgapuestomanipMld()
  {
    return (SgapuestomanipImpl)getAttributeInternal(SGAPUESTOMANIPMLD);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgapuestomanipImpl
   */
  public void setSgapuestomanipMld(SgapuestomanipImpl value)
  {
    setAttributeInternal(SGAPUESTOMANIPMLD, value);
  }


  /**
   * 
   *  Gets the associated entity SgapuestomanipImpl
   */
  public SgapuestomanipImpl getSgapuestomanipSlo()
  {
    return (SgapuestomanipImpl)getAttributeInternal(SGAPUESTOMANIPSLO);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgapuestomanipImpl
   */
  public void setSgapuestomanipSlo(SgapuestomanipImpl value)
  {
    setAttributeInternal(SGAPUESTOMANIPSLO, value);
  }



  /**
   * Allibera una ubicació del silo que esta pendent d'inpecció en funció del tamany
   * del mac que conte la ubicació
   */
  public boolean alliberarInspeccio(SgaposicionubicacionImpl posicion, Number numPos)
  {
    boolean bAlliberada = true;
    RowIterator macs = getSgamacPosicion();
    if (macs.getRowCount() > 0)
    {
      SgamacImpl mac = (SgamacImpl)macs.first();
      while (mac != null)
      {
        if (mac.getPosubipos().equals(posicion.getPosicion()))
        {
          // TODO: Que cony s'ha de fer amb el mac
          mac.remove();
        }
        mac = (SgamacImpl)macs.next();
      }
    }
    // Alliberem la posició
    updatePosiciones(LIBERAR, posicion, numPos);
    updatePosiciones(QUITARINSPECCIONAR, posicion, numPos);
    return bAlliberada;
  }


  /**
   * Força l'extracció des de una ubicació del silo que esta pendent d'inpecció en funció del tamany
   * del mac que conte la ubicació
   */
   
  public boolean inspeccionarUbicacio(SgaposicionubicacionImpl posicion, Number numPos, String desti, String idtipmac)
  {
    boolean inspeccionar = false;

    RowIterator macs = getSgamacPosicion();
    macs.reset();
    boolean trobat = false;
    SgamacImpl mac = null;
    while (macs.hasNext() && !trobat)
    {
      mac = (SgamacImpl)macs.next();
      if (mac.getPosubipos().equals(posicion.getPosicion()))
        trobat = true;
    }
    if (!trobat)
    {
      mac = (SgamacImpl)macs.createRow();
      // Xavi - Afegim la clau provinent de la sequencia seq_idart
      SequenceImpl idmacInspSeq = new SequenceImpl("SEQ_IDMACINSP", getDBTransaction());
      mac.setIdmac(idmacInspSeq.getSequenceNumber().toString());
      mac.setIdtipmac(idtipmac);
      mac.setUbides(posicion.getIdubi());
      mac.setPosubides(posicion.getPosicion());
      mac.setUbipos(posicion.getIdubi());
      mac.setPosubipos(posicion.getPosicion());
      macs.insertRow(mac);
    } 

    updatePosiciones(OCUPAR, posicion, numPos);
    updatePosiciones(QUITARINSPECCIONAR, posicion, numPos);

    // Fem la reserva del contenidor pel puesto    
    // Sempre se li passa el traslo 0 ...
    int traslo = 0;
    inspeccionar = mac.quizasReservarMacSalida(desti, traslo);
    return inspeccionar;
  }

  /**
   * 
   *  Creates a Key object based on given key constituents
   */
  public static Key createPrimaryKey(String idubi)
  {
    return new Key(new Object[] {idubi});
  }

}