package es.sysmap.interflex.model.bdc;
import es.sysmap.interflex.model.dmc.SgaposicionubicacionViewRowImpl;
import es.sysmap.interflex.model.dmc.SgavubicacionlibreminiloadViewRowImpl;
import es.sysmap.interflex.model.dmc.common.SgavubicacionlibreminiloadViewRow;
import es.sysmap.xml.XMLTelegrama;
import java.util.Vector;
import oracle.jbo.RowIterator;
import oracle.jbo.ViewObject;
import oracle.jbo.server.DBTransaction;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.domain.Number;
import oracle.jbo.Key;
import oracle.jbo.server.SequenceImpl;
import oracle.xml.parser.v2.XMLNode;
import org.w3c.dom.Node;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------

public class SgaubicacionMiniLoadImpl extends SgaubicacionImpl 
{
  public static final int MAXATTRCONST = EntityDefImpl.getMaxAttrConst("es.sysmap.interflex.model.bdc.Sgaubicacion");
  public static final int COLUMNA = MAXATTRCONST;
  public static final int NIVEL = MAXATTRCONST + 1;
  public static final int LADO = MAXATTRCONST + 2;
  public static final int ROTACION = MAXATTRCONST + 3;
  public static final int POSPLC = MAXATTRCONST + 4;
  public static final int ESTADO = MAXATTRCONST + 4;





  // Comprometiendo la reubicación del package de estas vistas... 
  private static String VUBICACIONLIBREMLD  = "es.sysmap.interflex.model.dmc.SgavubicacionlibreminiloadView";








  private static SgaubicacionDefImpl mDefinitionObject;

  /**
   * 
   *  This is the default constructor (do not remove)
   */
  public SgaubicacionMiniLoadImpl()
  {
  }

  /**
   * 
   *  Retrieves the definition object for this instance class.
   */
  public static synchronized EntityDefImpl getDefinitionObject()
  {
    if (mDefinitionObject == null)
    {
      mDefinitionObject = (SgaubicacionDefImpl)EntityDefImpl.findDefObject("es.sysmap.interflex.model.bdc.SgaubicacionMiniLoad");
    }
    return mDefinitionObject;
  }














  /**
   * 
   *  Gets the attribute value for Columna, using the alias name Columna
   */
  public Number getColumna()
  {
    return (Number)getAttributeInternal(COLUMNA);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Columna
   */
  public void setColumna(Number value)
  {
    setAttributeInternal(COLUMNA, value);
  }

  /**
   * 
   *  Gets the attribute value for Nivel, using the alias name Nivel
   */
  public Number getNivel()
  {
    return (Number)getAttributeInternal(NIVEL);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Nivel
   */
  public void setNivel(Number value)
  {
    setAttributeInternal(NIVEL, value);
  }

  /**
   * 
   *  Gets the attribute value for Lado, using the alias name Lado
   */
  public String getLado()
  {
    return (String)getAttributeInternal(LADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Lado
   */
  public void setLado(String value)
  {
    setAttributeInternal(LADO, value);
  }

  /**
   * 
   *  Gets the attribute value for Rotacion, using the alias name Rotacion
   */
  public String getRotacion()
  {
    return (String)getAttributeInternal(ROTACION);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Rotacion
   */
  public void setRotacion(String value)
  {
    setAttributeInternal(ROTACION, value);
  }

  /**
   * 
   *  Gets the attribute value for Estado, using the alias name Estado
   */
  public String getEstado()
  {
    return (String)getAttributeInternal(ESTADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Estado
   */
  public void setEstado(String value)
  {
    setAttributeInternal(ESTADO, value);
  }

  /**
   * 
   *  getAttrInvokeAccessor: generated method. Do not modify.
   */
  protected Object getAttrInvokeAccessor(int index, AttributeDefImpl attrDef) throws Exception
  {
    if (index == COLUMNA)
    {
      return getColumna();
    }
    if (index == NIVEL)
    {
      return getNivel();
    }
    if (index == LADO)
    {
      return getLado();
    }
    if (index == ROTACION)
    {
      return getRotacion();
    }
    if (index == IDTIPALM)
    {
      return getIdtipalm();
    }
    if (index == POSPLC)
    {
      return getPosplc();
    }
    return super.getAttrInvokeAccessor(index, attrDef);
  }

  /**
   * 
   *  setAttrInvokeAccessor: generated method. Do not modify.
   */
  protected void setAttrInvokeAccessor(int index, Object value, AttributeDefImpl attrDef) throws Exception
  {
    if (index == COLUMNA)
    {
      setColumna((Number)value);
      return;
    }
    if (index == NIVEL)
    {
      setNivel((Number)value);
      return;
    }
    if (index == LADO)
    {
      setLado((String)value);
      return;
    }
    if (index == ROTACION)
    {
      setRotacion((String)value);
      return;
    }
    if (index == POSPLC)
    {
      setPosplc((Number)value);
      return;
    }
    super.setAttrInvokeAccessor(index, value, attrDef);
    return;
  }



  /**
   * 
   *  Gets the attribute value for Idtipalm, using the alias name Idtipalm
   */
  public String getIdtipalm()
  {
    return super.getIdtipalm();
  }


  public String getTipoAlmacen()
  {
    return ("MiniLoad");
  }

  /**
   * 
   * @param numPos
   * @param posicion
   */
  public void liberarUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
    {
      posicion.liberarPosicion();
    }
  }

  public void ocuparUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
    {
      // En el miniload sólo se ocupa una posición
      posicion.ocuparPosicion();
    }
  }

  public void reservarUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
      // En el miniload sólo se ocupa una posición
      posicion.reservarPosicion();
  }
  
  public void quitarReservaUbicacion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
    {
      posicion.quitarReservaPosicion();
    }
  }
  
  public void setPendienteInspeccion(SgaposicionubicacionImpl posicion, Number numPos)
  {
    if (posicion != null)
    {
      posicion.setPendienteInspeccionPosicion();
    }
  }
  /**
   * Tratar un error de depósito del MAC
   * Marca el hueco actual pendiente de extracción
   * Busca un hueco alternativo para el mac
   * Si no hay hueco alternativa, saca el mac a un puesto
   * @return 
   * @param idTipmac no usado en este método pero necesario para la integredad de la clase base
   * @param posicion actual del mac
   */
  public SgaposicionubicacionImpl getPosicionUbicacionErrorDeposito(String idTipmac, SgaposicionubicacionImpl posicion)
  {
      DBTransaction txn = getDBTransaction();
      ViewObject vo = txn.createViewObject(VUBICACIONLIBREMLD);
      // Michael 10.01.2007 Sólo buscar en el mismo lado
      vo.setWhereClause("lado = '" + getLado() + "'");
      // Michael 10.01.2007 fin
      vo.executeQuery();
      vo.reset();
      while (vo.hasNext())
      {
        SgavubicacionlibreminiloadViewRowImpl row = (SgavubicacionlibreminiloadViewRowImpl)vo.next();
        // Que no sea la misma ubicación
        if (row.getIdubi().equals(getIdubi()) &&row.getPosicion().equals(posicion.getPosicion()))
          continue;
        SgaposicionubicacionViewRowImpl viewRow = (SgaposicionubicacionViewRowImpl)row.getSgaposicionubicacionView();
        SgaposicionubicacionImpl posUbi = viewRow.getSgaposicionubicacion();
        vo.remove();
        return posUbi;
      }
      return null;  // No ha encontrado nada
  }


  /**
   * Confeccionar el nodo XML correspondiente a la ubicación
   * @return 
   * @param node
   */
  public XMLNode getXMLUbicacion(XMLNode node)
  {
  try 
  {
    node.getFirstChild().setNodeValue(getPosplc().toString());
    XMLTelegrama.setValorNodo(node,"lado",getLado());
    // La columna del plc es siempre +1, ya que la cabecera es 1
    Number columna = getColumna().add(1);
    XMLTelegrama.setValorNodo(node,"columna", columna.toString());
    XMLTelegrama.setValorNodo(node,"nivel", getNivel().toString());
  } catch (Exception ex) 
  {
    LOG.error("getXMLUbicacion",ex);
  } 
    return node;
  }
  
  /**
   * 
   * @return el nodo XML correspondiente al siguiente destino desde esta posición
   * Para el miniload, siempre es el destino final
   * @param ubiDes
   * @param node
   */
  public XMLNode getXMLUbicacionSiguiente(XMLNode node, SgaubicacionImpl ubiDes)
  {
    return ubiDes.getXMLUbicacion(node);
  }

  
  public XMLNode getXMLUbicacionSiguiente(XMLNode node, SgaposicionubicacionImpl posUbiDes)
  {
    return posUbiDes.getXMLPosicion(node);
  }
  /**
   * 
   * @return el nodo XML correspondiente a la entrada del pasillo
   * Para el miniload, siempre es el destino final
   * @param ubiDes
   * @param node
   */
  public XMLNode getXMLUbicacionEntrada(XMLNode node)
  {
    return getXMLUbicacion(node);
  }
  

  /**
   * 
   *  Gets the attribute value for Posplc, using the alias name Posplc
   */
  public Number getPosplc()
  {
    return (Number)getAttributeInternal(POSPLC);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Posplc
   */
  public void setPosplc(Number value)
  {
    setAttributeInternal(POSPLC, value);
  }


  public String getDescripvisual()
  {
    String magatzem = /* getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Idtipalm")).getLabel(null)  + ": " + */ this.getIdtipalm();
    String costat = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Lado")).getLabel(null) + ": " + this.getLado();
    String columna = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Columna")).getLabel(null) + ": " + this.getColumna();
    String nivell = getEntityDef().getAttributeDefImpl(getAttributeIndexOf("Nivel")).getLabel(null) + ": " + this.getNivel();
    
    return magatzem + " " + costat + " " + columna + " " + nivell;
  }
 
 
  public void getDisponibilitat(SgaposicionubicacionImpl posicioUbicacio, Vector disponibilitat)
  {
    //Mirem que la posició estigui disponible
    posicioUbicacio.getDisponibilitatOcupada(disponibilitat);
    //Si la posicio es la segona, hem de mirar que la primera estigui tambe disponible
    if (posicioUbicacio.getPosicion().equals(new Number(2)))    
    {
      RowIterator posicions = getSgaposicionubicacion();
      posicions.reset();
      boolean trobat = false;
      while(posicions.hasNext() && !trobat)
      {
        SgaposicionubicacionImpl pos1 = (SgaposicionubicacionImpl)posicions.next();
        if (pos1.getPosicion().equals(new Number(1)))
        {
          trobat = true;
          SgamacImpl mac = (SgamacImpl)pos1.getSgamacPos().first();
          if (mac != null)
            mac.getDisponibilitat(disponibilitat);
          else
            pos1.getDisponibilitatLliure(disponibilitat);
        }
      }
    }
  }

  /**
   * Allibera una posició del miniload que esta pendent d'inspecció
   */
  public boolean alliberarInspeccio(SgaposicionubicacionImpl posicion, Number numPos)
  {
    boolean bAlliberada = true;
    RowIterator macs = getSgamacPosicion();
    if (macs.getRowCount() > 0)
    {
      SgamacImpl mac = (SgamacImpl)macs.first();
      while (mac != null)
      {
        if (mac.getPosubipos().equals(posicion.getPosicion()))
        {
          // TODO: Que cony s'ha de fer amb el mac
          mac.remove();
        }
        mac = (SgamacImpl)macs.next();
      }
    }
    // Alliberem la posició
    if (posicion != null)
    {
      posicion.liberarPosicion();
      posicion.anularPendienteInspeccionPosicion();
    }
    return bAlliberada;
  }


  /**
   * Força l'extracció desde una ubicació del miniload que esta pendent d'inspecció
   */
  public boolean inspeccionarUbicacio(SgaposicionubicacionImpl posicion, Number numPos, String desti, String idtipmac)
  {
    boolean inspeccionar = false;

    RowIterator macs = getSgamacPosicion();
    macs.reset();
    boolean trobat = false;
    SgamacImpl mac = null;
    while (macs.hasNext() && !trobat)
    {
      mac = (SgamacImpl)macs.next();
      if (mac.getPosubipos().equals(posicion.getPosicion()))
        trobat = true;
    }
    if (!trobat)
    {//TODO: crear sequencia per numerar el mac
      mac = (SgamacImpl)macs.createRow();
      // Xavi - Afegim la clau provinent de la sequencia seq_idart
      SequenceImpl idmacInspSeq = new SequenceImpl("SEQ_IDMACINSP", getDBTransaction());
      mac.setIdmac(idmacInspSeq.getSequenceNumber().toString());
      mac.setIdtipmac(idtipmac);
      mac.setUbides(posicion.getIdubi());
      mac.setPosubides(posicion.getPosicion());
      mac.setUbipos(posicion.getIdubi());
      mac.setPosubipos(posicion.getPosicion());
      macs.insertRow(mac);
    } 

    // Ocupem la posició
    if (posicion != null)
    {
      posicion.ocuparPosicion();
      posicion.anularPendienteInspeccionPosicion();
    }
      
    // Fem la reserva del contenidor pel puesto    
    // Sempre se li passa el traslo 0 ...
    int traslo = 0;
    inspeccionar = mac.quizasReservarMacSalida(desti, traslo);
    return inspeccionar;
  }

  /**
   * 
   *  Creates a Key object based on given key constituents
   */
  public static Key createPrimaryKey(String idubi)
  {
    return new Key(new Object[] {idubi});
  }






}