package es.sysmap.interflex.model.bdc;
import es.sysmap.interflex.model.bdc.common.FlexiDate;
import es.sysmap.interflex.model.dmc.AppModuleImpl;
import es.sysmap.interflex.model.dmc.common.AppModule;
import oracle.jbo.domain.Timestamp;
import oracle.jbo.server.DBTransaction;
import oracle.jbo.server.EntityImpl;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.Key;
import oracle.jbo.RowIterator;
import oracle.jbo.AttributeList;
import oracle.jbo.server.SequenceImpl;
import oracle.jbo.domain.Date;
import oracle.jbo.domain.Number;
import oracle.xml.parser.v2.XMLDocument;
import org.apache.log4j.Logger;
import oracle.jbo.server.TransactionEvent;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------

public class SgaordtranImpl extends EntityImpl 
{
  public static final int IDORD = 0;
  public static final int IDTIP = 1;
  public static final int ESTADO = 2;
  public static final int IDMAC = 3;
  public static final int IDORDREUBIC = 4;
  public static final int CREATEDBY = 5;
  public static final int CREATEDON = 6;
  public static final int MODIFIEDBY = 7;
  public static final int MODIFIEDON = 8;
  public static final int CODERROR = 9;
  public static final int IDTRASLO = 10;
  public static final int SEQMLD = 11;
  public static final int IDORDREUBICSGAORDTRAN = 12;
  public static final int IDORDREUBICSGAORDTRAN1 = 13;
  public static final int SGAORDTRAN = 14;
  public static final int SGAMAC = 15;
  public static final int SGAHISTORDTRAN = 16;
  public static final int SGAORDTRAN1 = 17;

  private Logger LOG = Logger.getLogger(getClass());


  public static final int LEN_TELE_MOVI = 68; // Tamaño de un telegrama de MOVI

  public static final int ERROREXTRACCION = 11; 
  
  public static final int ERRORDEPOSITO = 10; 
  public static final int ERRORCARGAINTERPUESTA = 13; // No se puede llegar a la segunda posición
  public static final int ERRORNOCARGAENORIGEN  = 14; // Intenta generar una orden sin carga en orígen (Empírico)
  public static final int ERRORTRASLOERRONEO = 12;  // Empírico






















































  private static SgaordtranDefImpl mDefinitionObject;

  /**
   * 
   *  This is the default constructor (do not remove)
   */
  public SgaordtranImpl()
  {
  }

  /**
   * 
   *  Retrieves the definition object for this instance class.
   */
  public static synchronized EntityDefImpl getDefinitionObject()
  {
    if (mDefinitionObject == null)
    {
      mDefinitionObject = (SgaordtranDefImpl)EntityDefImpl.findDefObject("es.sysmap.interflex.model.bdc.Sgaordtran");
    }
    return mDefinitionObject;
  }





























































  /**
   * 
   *  Gets the attribute value for Idord, using the alias name Idord
   */
  public Number getIdord()
  {
    return (Number)getAttributeInternal(IDORD);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idord
   */
  public void setIdord(Number value)
  {
    setAttributeInternal(IDORD, value);
  }

  /**
   * 
   *  Gets the attribute value for Idtip, using the alias name Idtip
   */
  public String getIdtip()
  {
    return (String)getAttributeInternal(IDTIP);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idtip
   */
  public void setIdtip(String value)
  {
    setAttributeInternal(IDTIP, value);
  }

  /**
   * 
   *  Gets the attribute value for Estado, using the alias name Estado
   */
  public String getEstado()
  {
    return (String)getAttributeInternal(ESTADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Estado
   */
  public void setEstado(String value)
  {
    setAttributeInternal(ESTADO, value);
    if (value != null)
    {
      if (value.equals("C"))
      {
        // En curso - actualizar fecha de actualización del históric
        SgahistordtranImpl histOrd = getSgahistordtranActual();
        if (histOrd != null)
        {
          histOrd.setFecasig(FlexiDate.currentDate());
        }
      }
    }
  }

  /**
   * 
   *  Gets the attribute value for Idmac, using the alias name Idmac
   */
  public String getIdmac()
  {
    return (String)getAttributeInternal(IDMAC);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idmac
   */
  public void setIdmac(String value)
  {
    setAttributeInternal(IDMAC, value);
  }

  /**
   * 
   *  Gets the attribute value for Idordreubic, using the alias name Idordreubic
   */
  public Number getIdordreubic()
  {
    return (Number)getAttributeInternal(IDORDREUBIC);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idordreubic
   */
  public void setIdordreubic(Number value)
  {
    setAttributeInternal(IDORDREUBIC, value);
  }

  /**
   * 
   *  getAttrInvokeAccessor: generated method. Do not modify.
   */
  protected Object getAttrInvokeAccessor(int index, AttributeDefImpl attrDef) throws Exception
  {
    switch (index)
      {
      case IDORD:
        return getIdord();
      case IDTIP:
        return getIdtip();
      case ESTADO:
        return getEstado();
      case IDMAC:
        return getIdmac();
      case IDORDREUBIC:
        return getIdordreubic();
      case CREATEDBY:
        return getCreatedby();
      case CREATEDON:
        return getCreatedon();
      case MODIFIEDBY:
        return getModifiedby();
      case MODIFIEDON:
        return getModifiedon();
      case CODERROR:
        return getCoderror();
      case IDTRASLO:
        return getIdtraslo();
      case SEQMLD:
        return getSeqmld();
      case SGAORDTRAN:
        return getSgaordtran();
      case SGAMAC:
        return getSgamac();
      case SGAHISTORDTRAN:
        return getSgahistordtran();
      case SGAORDTRAN1:
        return getSgaordtran1();
      case IDORDREUBICSGAORDTRAN:
        return getIdordreubicSgaordtran();
      case IDORDREUBICSGAORDTRAN1:
        return getIdordreubicSgaordtran1();
      default:
        return super.getAttrInvokeAccessor(index, attrDef);
      }
  }

  /**
   * 
   *  setAttrInvokeAccessor: generated method. Do not modify.
   */
  protected void setAttrInvokeAccessor(int index, Object value, AttributeDefImpl attrDef) throws Exception
  {
    switch (index)
      {
      case IDORD:
        setIdord((Number)value);
        return;
      case IDTIP:
        setIdtip((String)value);
        return;
      case ESTADO:
        setEstado((String)value);
        return;
      case IDMAC:
        setIdmac((String)value);
        return;
      case IDORDREUBIC:
        setIdordreubic((Number)value);
        return;
      case CODERROR:
        setCoderror((Number)value);
        return;
      case IDTRASLO:
        setIdtraslo((Number)value);
        return;
      case SEQMLD:
        setSeqmld((Number)value);
        return;
      default:
        super.setAttrInvokeAccessor(index, value, attrDef);
        return;
      }
  }



  /**
   * 
   *  Gets the associated entity SgaordtranImpl
   */
  public SgaordtranImpl getIdordreubicSgaordtran()
  {
    return (SgaordtranImpl)getAttributeInternal(IDORDREUBICSGAORDTRAN);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaordtranImpl
   */
  public void setIdordreubicSgaordtran(SgaordtranImpl value)
  {
    setAttributeInternal(IDORDREUBICSGAORDTRAN, value);
  }



  /**
   * 
   *  Add attribute defaulting logic in this method.
   */
  protected void create(AttributeList attributeList)
  {
    super.create(attributeList);

    // Sequencia de la orden...
    SequenceImpl seq = new SequenceImpl("SEQ_ORDTRAN",getDBTransaction());
    setIdord(seq.getSequenceNumber());

 
  }


  /**
   * 
   *  Gets the attribute value for Createdby, using the alias name Createdby
   */
  public String getCreatedby()
  {
    return (String)getAttributeInternal(CREATEDBY);
  }

  /**
   * 
   *  Gets the attribute value for Createdon, using the alias name Createdon
   */
  public Date getCreatedon()
  {
    return (Date)getAttributeInternal(CREATEDON);
  }

  /**
   * 
   *  Gets the attribute value for Modifiedby, using the alias name Modifiedby
   */
  public String getModifiedby()
  {
    return (String)getAttributeInternal(MODIFIEDBY);
  }

  /**
   * 
   *  Gets the attribute value for Modifiedon, using the alias name Modifiedon
   */
  public Date getModifiedon()
  {
    return (Date)getAttributeInternal(MODIFIEDON);
  }

  /**
   * 
   *  Gets the associated entity SgamacImpl
   */
  public SgamacImpl getSgamac()
  {
    return (SgamacImpl)getAttributeInternal(SGAMAC);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgamacImpl
   */
  public void setSgamac(SgamacImpl value)
  {
    setAttributeInternal(SGAMAC, value);
  }






  public XMLDocument getXMLMovi(XMLDocument xmldoc)
  {
    int tipMov = getEstado().equals("N") ? 0 : 2;
    return getSgamac().getXMLMovi(xmldoc, tipMov);
  }


  /**
   * Actualizar la posición del MAC por llegada de un telegrama Avis
   * Si ha dado error, será error de gálibo - poner el destino igual a la posición actual
   * Prerequisites: Un avis siempre indica una ubicación de PLC, que no tiene posición (no es hueco de almacén)
   * @param idUbiPosAct
   * @param codigoError
   */
  public void setAvis(int codigoError, String idUbiPosAct)
  {
    SgamacImpl mac = getSgamac();
    String ubiPosAnt = mac.getUbipos();
    
    if (codigoError == 0 || codigoError == 20)  // Error de gálibo
    {
      mac.setUbipos(idUbiPosAct);
      mac.setPosubipos(null); // La posición...

     // Michael 08.05.2005 Si estamos en el 27, borrar el traslo ya que puede ir a un segundo pasillo
     // 20.05.2005 if (mac.is27())
     // 20.05.2005  setIdtraslo(new Number(0));

      if (mac.is6o44() && codigoError == 20)
      {
        // La salida por 45 indica error de gálibo cada vez - ignorarlo
        if (!mac.is44destino45())
        {
          mac.setUbides(ubiPosAnt);
          mac.setPosubides(null);
        }
        else
          codigoError = 0;
      }
    }
    if (codigoError == 0   || codigoError == ERRORTRASLOERRONEO)
    {
      // Si el destino es el 45, siempre hay que borrar el traslo de esta orden
      // Cuando se recibe el PETI de esta orden es le envía la siguiente parte de la orden
      if (mac.isDestino45() && !mac.is44destino45())
      {
        setIdtraslo(new Number(0));
      }
        
      // Michael 20.05.2005 Si es salida pasillo, hay que enviar el destino
      if (mac.isPosPlc(26) || mac.isPosPlc(31) || mac.isPosPlc(36) || mac.isPosPlc(41))
      {
        setEstado("2");
        // Borrar el traslo ya que puede ir a otro pasillo
        setIdtraslo(new Number(0));
      }
      // Michael 20.05.2005 fin
      
      /* Michael 14.04.2005 No hace falta actualizar esto, ya que le falta su destino (hueco) final, por el proceso del traslo
      if (mac.isMoviPosicionAvis() && !is44destino45)
      {
        // Hay que continuar el movi desde esta posición
        setEstado("2");
      }
      */
    }
    
    if (codigoError != 0)
    {
      // :TODO Los otros avis no deben generar errores
      setCoderror(new Number(codigoError));
      // Michael 30.04.2005 Sólo si estamos en el gálibo para que vuelva al puesto
      // Michael 30.04.2005 Si es ERRORTRASLO, borra el traslo
      // Michael 07.05.2005 Reactivado esto
      if (codigoError == ERRORTRASLOERRONEO)
      {
        setIdtraslo(new Number (0));
      }
    }
    // Si hay un error en el avis, el mac continua y pide datos con un Peti.
    
  }
  
  private boolean isDeposito()
  {
    return getSgamac().isDestinoAlmacenAutomatico();
  }
  
  private boolean isExtraccion()
  {
    return getSgamac().isPosicionAlmacenAutomatico();
  }
  
  private void finalizarOrden()
  {
     SgamacImpl mac = getSgamac();
     mac.setLlegadoDestino();
     setEstado("B");  // el movimiento puede ser borrado
     // Ver si es una reubicación, con lo cual se puede lanzar la que le ha provocado
     SgaordtranImpl ordReubic = getIdordreubicSgaordtran();
     if (ordReubic != null)
      // No comprobamos que no este ya lanzado...
      ordReubic.setEstado("T");
    
  }
  
  
  /**
   * Generar movimiento de depósito desde la mesa de entrada del almacén,
   * según la matrícula leída
   * @param matricula
   */
  private void generarDepositoMLD(String matricula)
  {
    if (matricula != null)
    {
      if (getIdmac().indexOf(matricula) != -1)
      {
        // Es este - buscar depósito
        // TODO - como enviar el mac a su destino desde aquí
        AppModuleImpl appModule = (AppModuleImpl)getDBTransaction().getRootApplicationModule();
        appModule.generarDepositoMacMLD(getSgamac());
        
      }
      else
        LOG.error ("Ordre: " + getIdord() + " Mac: " + getIdmac() + " con lectura erronea de matricula");
        // TODO - implementar tratamiento
    }
    
  }

  
  /**
   * Finallzar un movimiento por llegada de un telegrama Fmov
   * Nota: No se mira el estado de la orden o si realmente el destino es el destino final
   * @param codigoError informado del PLC
   * @param posAct la posición actual (PLC) del mac
   */
  public void setFmov(int codigoError, int posAct, String matricula)
  {
     // Michael 31.05.2005 A veces llega un final de movimiento en la posición 58.
     // Como prueba, actualizar la posición y volver a enviar la orden ???
     /* Probar en Interflex
     if (posAct == SgaubicacionImpl.POSPLC_58)
     {
       LOG.error("Ordre: " + getIdord() + " Mac: " + getIdmac() + " en posició 58");
       // TODO VERY PROVISIONAL
       getSgamac().setUbipos("004404");
       setEstado("2");
       return;
     }
     *****/
     
     // Michael 11.07.2006 Si es la entrada al MLD,
     // Hay que enviar la orden con el destino final
     if (posAct == SgaubicacionImpl.POSPLC_58)
     {
       generarDepositoMLD(matricula);
       // Michael 12.07.2006 TODO - no se recibirá borrado de orden para este
       return;
     }
     // Si es la entrada extra, no hacer caso del error - que siempre lo indica...
     if (codigoError == 0 || posAct == SgaubicacionImpl.POSPLC_ENTRADA_EXTRA)
     { 
      finalizarOrden();
     }
     else
     {
      if (codigoError == ERROREXTRACCION && !isExtraccion())
      {
        // Puede haber dado error en la recogida del mac pero acaba bien
        finalizarOrden(); 
      }
      else
      {
        // De momento deja la orden en error hasta ver que tipos pueden ser
        LOG.error("Error (" + codigoError 
          + ") informat pel PLC en l'ordre de transport " + getIdord() 
          + " pel contenedor:"+ getIdmac());
        setCodigoErroneo(codigoError);
      }
    }
  }
  
  private void setCodigoErroneo(int codigoError)
  {
    setCoderror(new Number(codigoError));
    setEstado ("Z");
  }
  
  /**
   * Tratar un error de extracción 
   */
  private void setErrorExtraccion()
  {
    if (isExtraccion())
    {
      getSgamac().setErrorExtraccion();
      setCoderror(new Number(ERROREXTRACCION));
      setEstado ("B");  // Borra la orden
      // Ver si es una reubicación, con lo cual se debe bloquear el otro también
      SgaordtranImpl ordReubic = getIdordreubicSgaordtran();
      if (ordReubic != null)
       ordReubic.setErrorExtraccion();

    }
    else
    {
      LOG.error ("Error d'extracció incoherent " + getIdord() + " Container: " + getIdmac());
      // Aunque se ponga el código de error, si luego llega un final de orden, se actualiza como terminada
      setCodigoErroneo(ERROREXTRACCION);
    }
  }


  /**
   * Tratar un error de depósito
   */
  private void setErrorDeposito()
  {
    if (isDeposito())
    {
      getSgamac().setErrorDeposito();
      setEstado("2"); // Para que se vuelva a enviar al traslo
    }
    else
    {
      LOG.error ("Error de depósit incoherent " + getIdord() + " Container: " + getIdmac());
      setCodigoErroneo(ERRORDEPOSITO);

    }
    
    
  }
  
  
  /**
   * Actualizar la posición del MAC por llegada de un telegrama Peti
   * Si ha dado error, será error de depósito o extracción
   * @param idUbiPosAct
   * @param codigoError
   */
  public void setPeti(int codigoError, String idUbiPosAct)
  {
    SgamacImpl mac = getSgamac();



    
    // Michael 14.04.2005 Comprobar y borrar de aquí - mac.setPosubipos(null);
    if (codigoError == 0)
    {
     mac.setUbipos(idUbiPosAct);
  
     // Michael 17.04.2005 Si estamos en el 27, borrar el traslo ya que puede ir a un segundo pasillo
     if (mac.is27())
      setIdtraslo(new Number(0));
  
     if (mac.isMoviPosicionPeti())
      {
        // Hay que continuar el movi desde esta posición
        setEstado("2");
      }
    }
    else
    {
      switch (codigoError) 
      {
        case ERROREXTRACCION:  
          {
            setErrorExtraccion();
          }
          break;
        case ERRORCARGAINTERPUESTA:  // Michael 16.04.2005 TODO: Mismo tratamiento error extracción ?
          {
            setErrorExtraccion();
          }
          break;
        case ERRORDEPOSITO:  // Error de depósito :TODO - confirmar...
          {
            setErrorDeposito();
          }
          break;
        default:
          {
       // De momento deja la orden en error hasta ver que tipos pueden ser
          LOG.error("Error (" + codigoError 
            + ") informat pel PLC en l'ordre de transport " + getIdord() 
            + " pel contenedor:"+ getIdmac());
          mac.setUbipos(idUbiPosAct);
          setCodigoErroneo(codigoError);
          }
          break;
      }
    }
    
  }

  /**
   * Resetear el mac de la orden y borrar la orden
   * @param inspeccionarUbicacion si se debe dejar bloqueado la ubicación del mac
   * 
   */
  public void resetOrdtran(boolean inspeccionarUbicacion)
  {
    if (!(getEstado().equals("B") || getEstado().equals("b")))
    {
        // Resetear la posición del mac sólo si no ha transcurrido la orden
        getSgamac().resetOrdtran(inspeccionarUbicacion);
        // Michael 18.05.2005 Ponerlo pendiente de borrar para que se borre del PLC
        setEstado("B"); 
    }
    else
      // Si está ya en estado "B" y se borra manualmente, borralo.
      remove();
  }
  
  /**
   * Finalitzar una orden de transporte (manualmente)
   * Tratamiento como si llegara un final de movimiento
   * Si la orden está en estado "b", pendiente de aceptación de borrado
   *  o "Z", error - simplemente borrarla
   * 
   */
  public void finalizarOrdtran()
  {
    if (getEstado().equals("b") || getEstado().equals("Z"))
    {
      // ya se ha borrado - pendiente de borrar altogether then
      remove();
    }
    else
    { 
      // Michael 11.07.2006 compatibilidad parámetros
      setFmov(0, 0, null);  
    }
  }
  
  public void setDestinoTraslo(Number idTraslo, String idUbides, Number posicion)
  {
    getSgamac().setDestino(idUbides, posicion);
    setIdtraslo(idTraslo);
    setEstado("2"); // Segunda parte
    
  }
  
  public void setTraslo(Number idTraslo)
  {
    setIdtraslo(idTraslo);
    setEstado("2"); // Segunda parte

  }

  /**
   * 
   *  Gets the attribute value for Coderror, using the alias name Coderror
   */
  public Number getCoderror()
  {
    return (Number)getAttributeInternal(CODERROR);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Coderror
   */
  public void setCoderror(Number value)
  {
    setAttributeInternal(CODERROR, value);
  }


  /**
   * 
   *  Gets the attribute value for Idtraslo, using the alias name Idtraslo
   */
  public Number getIdtraslo()
  {
    return (Number)getAttributeInternal(IDTRASLO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idtraslo
   *  Actualizar el registro histórico si ha cambiado
   */
  public void setIdtraslo(Number value)
  {
    setAttributeInternal(IDTRASLO, value);
    if (value != null)
    {
      SgahistordtranImpl row = getSgahistordtranActual();
      if (row != null)
      {
        row.setIdtraslofin(value);
      }
    }
  }










  /**
   * 
   *  Gets the associated entity SgaordtranImpl
   */
  public SgaordtranImpl getSgaordtran()
  {
    return (SgaordtranImpl)getAttributeInternal(SGAORDTRAN);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaordtranImpl
   */
  public void setSgaordtran(SgaordtranImpl value)
  {
    setAttributeInternal(SGAORDTRAN, value);
  }


  /**
   * 
   *  Gets the associated entity oracle.jbo.RowIterator
   */
  public RowIterator getSgahistordtran()
  {
    return (RowIterator)getAttributeInternal(SGAHISTORDTRAN);
  }



  /**
   * 
   *  Custom DML update/insert/delete logic here.
   */
  protected void doDML(int operation, TransactionEvent e)
  {
    switch (operation)
    {
      case DML_INSERT:
        // Generar registro de histOrdTran
        SgahistordtranDefImpl histOrdTran = (SgahistordtranDefImpl)SgahistordtranImpl.getDefinitionObject();;
        histOrdTran.createInstance(getDBTransaction(), this, getSgamac());
        break;
      case DML_DELETE:
        SgahistordtranImpl histOrd = getSgahistordtranActual();
        if (histOrd != null)
          histOrd.setFinOrden(this, getSgamac());
    }
    super.doDML(operation, e);
  }

  /**
   * 
   *  Gets the associated entity SgaordtranImpl
   */
  public SgaordtranImpl getIdordreubicSgaordtran1()
  {
    return (SgaordtranImpl)getAttributeInternal(IDORDREUBICSGAORDTRAN1);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaordtranImpl
   */
  public void setIdordreubicSgaordtran1(SgaordtranImpl value)
  {
    setAttributeInternal(IDORDREUBICSGAORDTRAN1, value);
  }

  /**
   * 
   *  Gets the associated entity oracle.jbo.RowIterator
   */
  public RowIterator getSgaordtran1()
  {
    return (RowIterator)getAttributeInternal(SGAORDTRAN1);
  }

  
  

  /**
   * 
   *  El registro historico en curso
   */
  public SgahistordtranImpl getSgahistordtranActual()
  {
    RowIterator histRows = getSgahistordtran();
    while (histRows.hasNext())
    {
      SgahistordtranImpl row = (SgahistordtranImpl)histRows.next();
      if (row.getEstado().equals("C"))
        return row;
    }
    return null;
  }


  /**
   * 
   *  Gets the attribute value for Seqmld, using the alias name Seqmld
   */
  public Number getSeqmld()
  {
    return (Number)getAttributeInternal(SEQMLD);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Seqmld
   */
  public void setSeqmld(Number value)
  {
    setAttributeInternal(SEQMLD, value);
  }

  /**
   * 
   *  Creates a Key object based on given key constituents
   */
  public static Key createPrimaryKey(Number idord)
  {
    return new Key(new Object[] {idord});
  }
























  







}