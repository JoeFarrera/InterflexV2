package es.sysmap.interflex.model.bdc;
import es.sysmap.interflex.model.bdc.SgaordtranDefImpl;
import es.sysmap.interflex.model.bdc.SgaposicionubicacionImpl;
import es.sysmap.interflex.model.bdc.SgaubicacionImpl;
import es.sysmap.interflex.model.bdc.SgaubicacionMiniLoadImpl;
import es.sysmap.interflex.model.bdc.common.FlexiDate;
import es.sysmap.interflex.model.dmc.common.SgavubicacionlibreminiloadViewRow;
import es.sysmap.xml.XMLHelper;

import es.sysmap.xml.XMLTelegrama;
import java.util.Vector;
import oracle.jbo.AttributeList;
import oracle.jbo.JboException;
import oracle.jbo.Key;
import oracle.jbo.Row;
import oracle.jbo.RowIterator;
import oracle.jbo.ViewObject;
import oracle.jbo.domain.Number;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.server.DBTransaction;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.EntityImpl;

import oracle.sql.NUMBER;
import oracle.xml.parser.v2.XMLDocument;
import oracle.xml.parser.v2.XMLNode;
import oracle.xml.parser.v2.XSLException;

import org.apache.log4j.Logger;

import org.w3c.dom.Node;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------

public class SgamacImpl extends EntityImpl 
{
  public static final int IDMAC = 0;
  public static final int MULTIREF = 1;
  public static final int IDTIPMAC = 2;
  public static final int ESTADO = 3;
  public static final int UBIPOS = 4;
  public static final int POSUBIPOS = 5;
  public static final int UBIDES = 6;
  public static final int POSUBIDES = 7;
  public static final int CREATEDBY = 8;
  public static final int MODIFIEDBY = 9;
  public static final int CREATEDON = 10;
  public static final int MODIFIEDON = 11;
  public static final int TARA = 12;
  public static final int SGAPOSUBIDES = 13;
  public static final int SGAPOSUBIPOS = 14;
  public static final int SGATIPOMAC = 15;
  public static final int SGAUBICACIONDESTINO = 16;
  public static final int SGAUBICACIONPOSICION = 17;
  public static final int SGAORDTRAN = 18;
  public static final int SGARESMAT = 19;
  public static final int SGAEXISTENCIA = 20;
  public static final int SGARESMATMANY = 21;
  public static final int SGAMACTARA = 22;


  
  private static String VMAX2APOSICIONMINILOAD = "es.sysmap.interflex.model.dmc.Sgavmac2aposicionminiloadView";

  private static String VUBICACIONLIBREMINILOAD  = "es.sysmap.interflex.model.dmc.SgavubicacionlibreminiloadView";


















  private static EntityDefImpl mDefinitionObject;

  /**
   * 
   *  This is the default constructor (do not remove)
   */
  public SgamacImpl()
  {
  }

  /**
   * 
   *  Retrieves the definition object for this instance class.
   */
  public static synchronized EntityDefImpl getDefinitionObject()
  {
    if (mDefinitionObject == null)
    {
      mDefinitionObject = (EntityDefImpl)EntityDefImpl.findDefObject("es.sysmap.interflex.model.bdc.Sgamac");
    }
    return mDefinitionObject;
  }


















  /**
   * 
   *  Gets the attribute value for Idmac, using the alias name Idmac
   */
  public String getIdmac()
  {
    return (String)getAttributeInternal(IDMAC);
  }
  
  public String getDescripUbipos()
  {
    String pos = (getPosubipos() != null) ? " Pos: " + getPosubipos() : " ";
    return "P: " + getSgaUbicacionPosicion().getDescripvisual() + pos;
  }
  
  public String getDescripUbides()
  {
    String pos = (getPosubides() != null) ? " Pos: " + getPosubides() : " ";
    return "D: " + getSgaUbicacionDestino().getDescripvisual() + pos;
  }

  
  /**
   * devolver el idMac en el formato esperado por el telegrama movi del PLC
   * @return la matrícula del mac
   */
  private String getIdmacMovi()
  {
    String matricula = getIdmac();
    int lenMatricula = getIdmac().length();
    if (lenMatricula > 10)
    {
      matricula = matricula.substring(lenMatricula - 10, lenMatricula);
    }
    return matricula;
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idmac
   */
  public void setIdmac(String value)
  {
    // Xavi, 06/05/05: no deixem introduir un identificador de mac amb una longitut menor
    // a la de la definició del camp
    if (value != null)
    {
      if (value.length() < getEntityDef().getAttributeDef(IDMAC).getPrecision())
          throw new JboException(InterflexMessageBundle.class,
                    InterflexMessageBundle.MAC_IDENTIFICADOR_INCORRECTE,
                         new Object[] {value});
    }
    // Fi modificació
    
    // Michael 15.01.2009 get the tara if not previously informed
    boolean wasNull = false;
    if(getIdmac() == null && value != null)
      wasNull = true;
      
    setAttributeInternal(IDMAC, value);
    
    if (wasNull)
    // Recuperar la tara si existe
    {
      SgamactaraImpl macTara = getSgamactara();
      if (macTara != null)
      {
        setTara(macTara.getTara());
      }
    }
      
    
  }

  /**
   * 
   *  Gets the attribute value for Multiref, using the alias name Multiref
   */
  public String getMultiref()
  {
    return (String)getAttributeInternal(MULTIREF);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Multiref
   */
  public void setMultiref(String value)
  {
    setAttributeInternal(MULTIREF, value);
  }

  /**
   * 
   *  Gets the attribute value for Idtipmac, using the alias name Idtipmac
   */
  public String getIdtipmac()
  {
    return (String)getAttributeInternal(IDTIPMAC);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Idtipmac
   */
  public void setIdtipmac(String value)
  {
    setAttributeInternal(IDTIPMAC, value);
  }

  /**
   * 
   *  Gets the attribute value for Estado, using the alias name Estado
   */
  public String getEstado()
  {
    return (String)getAttributeInternal(ESTADO);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Estado
   */
  public void setEstado(String value)
  {
    setAttributeInternal(ESTADO, value);
  }

  /**
   * 
   *  Gets the attribute value for Ubipos, using the alias name Ubipos
   */
  public String getUbipos()
  {
    return (String)getAttributeInternal(UBIPOS);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Ubipos
   */
  public void setUbipos(String value)
  {
  
  if (value != null && !value.equals(getUbipos()) || (value == null && getUbipos() != null))
  {
    SgaubicacionImpl ubiPos = getSgaUbicacionPosicion();
    if (ubiPos != null)
    {
      ubiPos.liberarUbicacion(getSgaposubipos(), getNumpos());
    }
  }
  setAttributeInternal(UBIPOS, value);
  // Michael 07.04.2005 Nullify posubipos para evitar problemas de constraints
  setPosubipos(null);
  // Se ocupa la ubicación cuando se pone la posición
  }

  private Number getNumpos()
  {
    return getSgatipomac().getNumpos();
  }

  /**
   * 
   *  Gets the attribute value for Posubipos, using the alias name Posubipos
   */
  public Number getPosubipos()
  {
    return (Number)getAttributeInternal(POSUBIPOS);
  }
  
  /**
   * Liberar la posición - sólo en el caso que la ubicación no cambia
   */
  public void liberarPosicion()
  {
    if (getSgaposubipos() != null)
      getSgaposubipos().liberarPosicion();
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Posubipos
   *  Ocupar la ubicación cuando se ha puesto la posición
   *  Si la posición es igual al destino, y son del silo o miniload, actualiza el
   *   estado del mac a libre
   *  Michael 13.04.2005 si es puesto de picking miniload, hay que ocupar la primera posicion libre
   */
  public void setPosubipos(Number value)
  {
   setAttributeInternal(POSUBIPOS, value);

   SgaubicacionImpl ubiPos = getSgaUbicacionPosicion();
   if (ubiPos != null)
   {
        ubiPos.ocuparUbicacion(getSgaposubipos(), getNumpos());
        if (ubiPos.equals(getSgaUbicacionDestino()))
        {
          if (ubiPos instanceof SgaubicacionSiloImpl || ubiPos instanceof SgaubicacionMiniLoadImpl)
            setEstado ("L");
          else
          {
            if (ubiPos.isPickingMiniload() && value == null)
             {
              SgapuestoPickingImpl picking = (SgapuestoPickingImpl)ubiPos;
              SgaposicionubicacionImpl pos = picking.getFirstPosicionLibre();
              if (pos == null)
                  throw new JboException(InterflexMessageBundle.class,
                            InterflexMessageBundle.SENSE_POSICION_EN_PKMLD,
                                 new Object[] {picking.getDescripvisual()});
                                 
             picking.ocuparUbicacion(pos, new Number (0));
             setAttributeInternal(POSUBIPOS, pos.getPosicion());
             }
          }
      }
  }
 }

  /**
   * 
   *  Gets the attribute value for Ubides, using the alias name Ubides
   */
  public String getUbides()
  {
    return (String)getAttributeInternal(UBIDES);
  }

  public void setDestino(String ubides, Number posicion)
  {
    setUbides(ubides);
    setPosubides(posicion);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Ubides
   */
  public void setUbides(String value)
  {
  
    if (value != null && !value.equals(getUbides()) || (value == null && getUbides() != null))
    {
      SgaubicacionImpl ubiDes = getSgaUbicacionDestino();
      if (ubiDes != null)
      {
        ubiDes.quitarReservaUbicacion(getSgaposubides(), getNumpos());
      }
      
    }
    
    // Se reserva la ubicación cuando se pone la posición
    setAttributeInternal(UBIDES, value);
  }

  /**
   * 
   *  Gets the attribute value for Posubides, using the alias name Posubides
   */
  public Number getPosubides()
  {
    return (Number)getAttributeInternal(POSUBIDES);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Posubides
   *  Reservar la ubicación destino
  */
  public void setPosubides(Number value)
  {
    setAttributeInternal(POSUBIDES, value);
 
   SgaubicacionImpl ubiDes = getSgaUbicacionDestino();
   if (ubiDes != null)
   {
      // Michael 13.01.2006 Sólo reservar la ubicación si es diferente de la actual
      SgaubicacionImpl ubiPos = getSgaUbicacionPosicion();
      if (ubiPos == null || !ubiPos.equals(ubiDes))
      {
        // Reservar un número de posiciones correspondiente a las que ocupa el MAC
        ubiDes.reservarUbicacion(getSgaposubides(), getNumpos());
      }
   }
   
  }

  /**
   * 
   *  getAttrInvokeAccessor: generated method. Do not modify.
   */
  protected Object getAttrInvokeAccessor(int index, AttributeDefImpl attrDef) throws Exception
  {
    switch (index)
      {
      case IDMAC:
        return getIdmac();
      case MULTIREF:
        return getMultiref();
      case IDTIPMAC:
        return getIdtipmac();
      case ESTADO:
        return getEstado();
      case UBIPOS:
        return getUbipos();
      case POSUBIPOS:
        return getPosubipos();
      case UBIDES:
        return getUbides();
      case POSUBIDES:
        return getPosubides();
      case CREATEDBY:
        return getCreatedby();
      case MODIFIEDBY:
        return getModifiedby();
      case CREATEDON:
        return getCreatedon();
      case MODIFIEDON:
        return getModifiedon();
      case TARA:
        return getTara();
      case SGAEXISTENCIA:
        return getSgaexistencia();
      case SGARESMATMANY:
        return getSgaresmatMany();
      case SGAMACTARA:
        return getSgamactara();
      case SGAPOSUBIDES:
        return getSgaposubides();
      case SGAPOSUBIPOS:
        return getSgaposubipos();
      case SGATIPOMAC:
        return getSgatipomac();
      case SGAUBICACIONDESTINO:
        return getSgaUbicacionDestino();
      case SGAUBICACIONPOSICION:
        return getSgaUbicacionPosicion();
      case SGAORDTRAN:
        return getSgaordtran();
      case SGARESMAT:
        return getSgaresmat();
      default:
        return super.getAttrInvokeAccessor(index, attrDef);
      }
  }

  /**
   * 
   *  setAttrInvokeAccessor: generated method. Do not modify.
   */
  protected void setAttrInvokeAccessor(int index, Object value, AttributeDefImpl attrDef) throws Exception
  {
    switch (index)
      {
      case IDMAC:
        setIdmac((String)value);
        return;
      case MULTIREF:
        setMultiref((String)value);
        return;
      case IDTIPMAC:
        setIdtipmac((String)value);
        return;
      case ESTADO:
        setEstado((String)value);
        return;
      case UBIPOS:
        setUbipos((String)value);
        return;
      case POSUBIPOS:
        setPosubipos((Number)value);
        return;
      case UBIDES:
        setUbides((String)value);
        return;
      case POSUBIDES:
        setPosubides((Number)value);
        return;
      case TARA:
        setTara((Number)value);
        return;
      default:
        super.setAttrInvokeAccessor(index, value, attrDef);
        return;
      }
  }



  /**
   * 
   *  Gets the associated entity oracle.jbo.RowIterator
   */
  public RowIterator getSgaexistencia()
  {
    return (RowIterator)getAttributeInternal(SGAEXISTENCIA);
  }







  /**
   * 
   *  Gets the associated entity SgatipomacImpl
   */
  public SgatipomacImpl getSgatipomac()
  {
    return (SgatipomacImpl)getAttributeInternal(SGATIPOMAC);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgatipomacImpl
   */
  public void setSgatipomac(SgatipomacImpl value)
  {
    setAttributeInternal(SGATIPOMAC, value);
  }







  /**
   * 
   *  Gets the attribute value for Createdby, using the alias name Createdby
   */
  public String getCreatedby()
  {
    return (String)getAttributeInternal(CREATEDBY);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Createdby
   */
  public void setCreatedby(String value)
  {
    setAttributeInternal(CREATEDBY, value);
  }

  /**
   * 
   *  Gets the attribute value for Modifiedby, using the alias name Modifiedby
   */
  public String getModifiedby()
  {
    return (String)getAttributeInternal(MODIFIEDBY);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Modifiedby
   */
  public void setModifiedby(String value)
  {
    setAttributeInternal(MODIFIEDBY, value);
  }

  /**
   * 
   *  Gets the attribute value for Createdon, using the alias name Createdon
   */
  public FlexiDate getCreatedon()
  {
    return (FlexiDate)getAttributeInternal(CREATEDON);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Createdon
   */
  public void setCreatedon(FlexiDate value)
  {
    setAttributeInternal(CREATEDON, value);
  }

  /**
   * 
   *  Gets the attribute value for Modifiedon, using the alias name Modifiedon
   */
  public FlexiDate getModifiedon()
  {
    return (FlexiDate)getAttributeInternal(MODIFIEDON);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Modifiedon
   */
  public void setModifiedon(FlexiDate value)
  {
    setAttributeInternal(MODIFIEDON, value);
  }


  /**
   * 
   *  Gets the associated entity SgaordtranImpl
   */
  public SgaordtranImpl getSgaordtran()
  {
    return (SgaordtranImpl)getAttributeInternal(SGAORDTRAN);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaordtranImpl
   */
  public void setSgaordtran(SgaordtranImpl value)
  {
    setAttributeInternal(SGAORDTRAN, value);
  }


  private boolean isReserved()
  {
    // Michael 25.04.2005 Si el estado es "P", en puesto, considera como reservado
    return (getEstado().equals("R") || getEstado().equals("P"));
  }
  
  /**
   * Ver si se puede reservar el MAC para hacer una salida
   * Un MAC es reservable si:
   *  <li>El MAC tiene un estado libre</li>
   *  <li>la posición y destino del MAC son iguales</li>
   *  <li>el mac está libre</li>
   *  <li>la ubicación actual del MAC se puede reservar</li>
   *  
   * <p><em>Nota: Si el MAC no tiene una posición definida, se puede reservar</em></p>
   * @return true si se puede reservar para una salida
   */
  public boolean isReservableSalida()
  {
    boolean retVal = false;
    
    if (!getEstado().equals("L"))
      return false;
      
    if (getUbipos().equals(getUbides()) && getPosubipos().equals(getPosubides()))
    {
      // Mira a ver si la posición permite realizar una salida
      SgaposicionubicacionImpl posUbi = getSgaposubipos();
      if (posUbi != null)
        retVal = posUbi.isReservableSalida();
      else
        retVal = true;  // Si no tiene posición, se puede reservar ?
    }
    return retVal;
  }
  
  
  /**
   * Ver si el destino del mac corresponde a un almacén automático
   * @return 
   */
  public boolean isDestinoAlmacenAutomatico()
  {
    return getSgaUbicacionDestino().isAlmacenAutomatico();
  }
  
  public boolean isPosicionAlmacenAutomatico()
  {
    return getSgaUbicacionPosicion().isAlmacenAutomatico();
  }

  public boolean isMiniload()
  {
    return getSgatipomac().isMiniload();
  }
  
  public boolean isManual()
  {
    return getSgatipomac().isManual();
  }  
  
  
  /**
   * Mirar si se puede reservar el mac para salir
   * Si es un mac del miniload, ver si tiene otro mac delante
   * Si hay otro mac delante, reserva este primero, y el otro a continuación
   * 
   * @return exito de la operación
   * @param posDes la posición destino del MAC
   */
  public boolean quizasReservarMacSalida(String idUbides, int idTraslo)
  {
    boolean retVal = false;
    if (isReserved())
      return true;
    
    if (isReservableSalida())
    {
        String otroMac = isPosicion2MiniLoad();
        if (otroMac != null)
        {
          // Hay un MAC en la primera posición que hay que reubicar
          Object [] keyOb = new Object [] { otroMac };
          Key macKey = new Key (keyOb);
          SgamacImpl otroMacImpl = (SgamacImpl)SgamacImpl.getDefinitionObject().findByPrimaryKey(getDBTransaction(), macKey);
          if (otroMacImpl.isReservableSalida())
          {
            if (otroMacImpl.setUbicacionMismoPasillo())
            {
              reservarSalida(idUbides, otroMacImpl, idTraslo);
              retVal = true;
            }
          }
          else
            retVal = false;
        }
        else
        {
          // No hay otro MAC delante
          reservarSalida(idUbides, null, idTraslo);
          retVal = true;
        }
    }
    else
        retVal = false;
    
    return retVal;
  }

  private void setPosicionNode(XMLNode node, SgaubicacionImpl ubicacion, Number pos)
  {
    try
    {
      node.getFirstChild().setNodeValue(ubicacion.getIdubi());
      if (pos != null)
      {
        Node posNode = node.selectSingleNode("posUbicacion");
        posNode.getFirstChild().setNodeValue(pos.toString());
      }
      // TODO - como acceder a lado, columna, nivel etc...
    } catch (XSLException ex)
    {
//      LOG.error("Exception:", ex);
    }
    
  }
  
  /**
   * Confeccionar el documento XML correspondiente al movimiento del MAC
   * desde su posición a su destino
   * Preconditions:
   *  El mac tiene una orden de transporte generada
   * @param tipMov tipo de movimiento
   * @param xmldoc
   * @return XMLDocument correspondiente al movi
   */
  public XMLDocument getXMLMovi(XMLDocument xmldoc, int tipMov)
  {
    SgaordtranImpl ordTran = getSgaordtran();

    assert ordTran != null;

   try
    {
      XMLTelegrama.setNumMovimiento(xmldoc, ordTran.getIdord().intValue());
      XMLNode detailNode = (XMLNode)xmldoc.selectSingleNode("Telegrama/Detalles");
      
      String idTraslo = ordTran.getIdtraslo().toString();
      String tipCarga = getSgatipomac().getTipplc().toString();
      XMLTelegrama.setValorNodo(detailNode, "tipCarga", tipCarga);  
      XMLTelegrama.setValorNodo(detailNode,"tipMov",Integer.toString(tipMov)); 
      XMLTelegrama.setValorNodo(detailNode,"pesTeorico","0");
      XMLTelegrama.setValorNodo(detailNode,"pesReal","0");
      XMLTelegrama.setValorNodo(detailNode,"tolPeso","0");
      XMLTelegrama.setValorNodo(detailNode,"numCargas","0");
      XMLTelegrama.setValorNodo(detailNode,"numLote","0");
      XMLTelegrama.setValorNodo(detailNode,"posAct", getSgaUbicacionPosicion().getPosplc().toString());
      XMLTelegrama.setValorNodo(detailNode,"codError","0");
      XMLTelegrama.setValorNodo(detailNode,"estadoOrden","0"); // TODO - confirmar
      XMLTelegrama.setValorNodo(detailNode,"transelevador", idTraslo);
      XMLTelegrama.setValorNodo(detailNode,"matricula",getIdmacMovi()); 
      // Michael 01.12.2006 doble cubeta
      String seqmld = "0";
      Number seq = ordTran.getSeqmld();
      if (seq != null)
          seqmld = seq.toString();
      XMLTelegrama.setValorNodo(detailNode,"seqmld",seqmld);
      // Michael 01.12.2006 fin
      
      
      // Inicializar el nodo de la posición
      XMLNode node = (XMLNode)detailNode.selectSingleNode("origen");
      SgaposicionubicacionImpl posImpl = getSgaposubipos();
      if (posImpl != null)
        posImpl.getXMLPosicion(node);
      else
      {
        // No tiene posición
        XMLTelegrama.setValorNodo(node, "posUbicacion", "0");
        getSgaUbicacionPosicion().getXMLUbicacion(node);
      }
      
      // Inicializar el node del destino
      node = (XMLNode)detailNode.selectSingleNode("destino");
      SgaposicionubicacionImpl desImpl = getSgaposubides();
//      LOG.debug("idMac: " + getIdmac() + " ubicacion destino: " + getUbides() + " desImp != null: " + (desImpl != null));
      if (desImpl != null)
        getSgaUbicacionPosicion().getXMLUbicacionSiguiente(node, (SgaposicionubicacionImpl)desImpl);
      else
      {
        // El destino no tiene posición
        XMLTelegrama.setValorNodo(node, "posUbicacion", "0");
        getSgaUbicacionPosicion().getXMLUbicacionSiguiente(node, getSgaUbicacionDestino());
      }
    
   } catch (XSLException ex)
    {
//      LOG.error("Exception:", ex);
    }

        

    return xmldoc;
    
  }
  
  
  /**
   * Buscar una ubicación en el mismo pasillo (miniload) y generar la orden de transporte
   * Si no encuentra ubicación, no puede mover el contenedor.
   * @return true si se ha movido, false si no
   */
  private boolean setUbicacionMismoPasillo()
  {
    boolean retVal = false;
    ViewObject vo = getDBTransaction().createViewObject(VUBICACIONLIBREMINILOAD);
    // TODO Execute ??
    if (vo.hasNext())
    {
      SgavubicacionlibreminiloadViewRow typedRow = (SgavubicacionlibreminiloadViewRow)vo.first();
      setUbides(typedRow.getIdubi());
      setPosubides(typedRow.getPosicion());
      generarOrdTranSalida(0);  // El traslo es 0 en el Mini Load
      retVal = true;
    }
    else;
//      LOG.error("No se ha trovat cap ubicació alternativa pel contenidor: " + getIdmac());
    vo.remove();
    return retVal;

  }
  
  /**
   * Cuando sale la cubeta del miniload, se pone en posición 0.
   * Pero antes debe mover los otros
   * Habra un momento que hay dos en la posición 1
   */
  private void setMiniloadPosicionZero()
  {
    SgaposicionubicacionImpl posubipos = getSgaposubipos();
    getSgaUbicacionPosicion().liberarUbicacion(posubipos, new Number(1));
    setPosubipos(new Number(0));
  }
  
  /**
   * Actualizar el destino de un movimiento de entrada y ponerlo para enviar de nuevo
   * @param idUbides el destino nuevo
   */
  public void actualizarMovimientoEntrada(String idUbides)
  {
    setUbides(idUbides);
    setPosubides(null);
    SgaordtranImpl ordTran = getSgaordtran();
    ordTran.setEstado("2"); // Segunda parte de la orden
    
  }
  
  /**
   * Actualizar el mac para un movimiento de una ubicación a otro (hacia entrada)
   * Si es el miniload, actualiza la posición actual del mac para que puede entrar otro en el puesto
   * @param idTraslo
   * @param posicion
   * @param idUbides
   */
  public void reservarMovimientoEntrada(String idUbides, Number posicion, int idTraslo)
  {
    setUbides(idUbides);
    setPosubides(posicion);
    if (isMiniload())
        // setUbipos(SgaubicacionImpl.PKML99); no puede ser ya que no sale por el PLC
        // Ponle en la posición 0 para que salga 16.04.2005
        setMiniloadPosicionZero();
    generarOrdTran("E", null, idTraslo);
  }
  
  
  public void reservarMovimientoEntradaMLD(String idUbides, Number posicion)
  {
    setUbides(idUbides);
    setPosubides(posicion);
    getSgaordtran().setEstado("2"); // Continuamos con la misma orden
  }
  
  public void reservarSalida(String idUbides, SgamacImpl otroMac, int idTraslo)
  {
    setUbides(idUbides);
    setPosubides(null); // Cuando es una salida, será hacia una ubicación que no tiene posición
    if (otroMac != null)
      generarOrdTranReubicacion(otroMac, idTraslo);
    else
      generarOrdTranSalida(idTraslo);
  }
  
  private void generarOrdTranSalida(int idTraslo)
  {
    generarOrdTran("S", null, idTraslo);
  }
  
  private void generarOrdTranReubicacion(SgamacImpl otroMac, int idTraslo)
  {
    generarOrdTran("S", otroMac, idTraslo);
  }
  
  /**
   * Generar una orden de transporte
   * Si es un mac del miniload, se inserta en estado nuevo "N" o reubicacion "R" si es que espera una reubicación
   * Si es del silo, se inserta en estado "T" Pendiente de traslo, si no trae un número de traslo para realizar la orden
   * @param idTraslo El traslo que debe realizar la orden: 0 es miniload o no especificado
   * @param otroMac Si es una orden que requiere la salida primera de otro mac (delante), aquí estará indicado
   * @param idTipOrd Entrada o salida - Michael 08.04.2005 Quizas quitar este atributo ??
   */
  private void generarOrdTran (String idTipOrd, SgamacImpl otroMac, int idTraslo)
  {
    SgaordtranDefImpl ordtran = (SgaordtranDefImpl)SgaordtranImpl.getDefinitionObject();
    Number otraOrdTran;
    String estado;
    if (otroMac == null)
    {
      otraOrdTran = null;
/*
 * if (isMiniload())
        estado = "N"; 
      else
      {
        if (idTraslo == 0)
          estado = "T";
        else
          estado = "N";
      }
*/
    // Michael 09.04.2005 En todos los casos una T
    if (idTipOrd.equals("E"))
      estado = "N";
    else
      estado = "T"; 
    }
    else
    {
      otraOrdTran = otroMac.getSgaordtran().getIdord();
      estado = "R"; // Crear la orden en estado pendiente de una reubicación
    }
    ordtran.createInstance(getDBTransaction(), getIdmac(), idTipOrd, estado, otraOrdTran, idTraslo);
    setEstado ("R"); 
  }


  /**
   * Si el mac es del miniload, es de la segunda posición, y hay otro mac en la primera, 
   * devuelva ésta.
   * @returns String null si no hay otro mac, El idMac si hay otro
   */
  private String isPosicion2MiniLoad()
  {
    int posUbipos = getPosubipos().intValue();
    if (posUbipos == 2 && getSgaUbicacionPosicion().getTipoAlmacen().equals("MiniLoad"))
    {
      // Mirar a ver si hay otro ocupando la primera posición
      DBTransaction txn = getDBTransaction();
      ViewObject vo = txn.createViewObject(VMAX2APOSICIONMINILOAD);
      vo.setWhereClauseParam(0,getIdmac());
      // TODO Execute ??
      // TODO - una vez encontrado la primera, hay que mirar que se pueda reservar también...
      if (vo.hasNext())
      {
        Row row = vo.first();
        String idMacPos1 = row.getAttribute("Idmacpos1").toString();
        return idMacPos1;
      }
      vo.remove();
      return null;
    }
    else
      return null;
  }










  /**
   * 
   *  Gets the associated entity SgaubicacionImpl
   */
  public SgaubicacionImpl getSgaUbicacionDestino()
  {
    return (SgaubicacionImpl)getAttributeInternal(SGAUBICACIONDESTINO);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaubicacionImpl
   */
  public void setSgaUbicacionDestino(SgaubicacionImpl value)
  {
    setAttributeInternal(SGAUBICACIONDESTINO, value);
  }





  /**
   * 
   *  Gets the associated entity SgaubicacionImpl
   */
  public SgaubicacionImpl getSgaUbicacionPosicion()
  {
    return (SgaubicacionImpl)getAttributeInternal(SGAUBICACIONPOSICION);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaubicacionImpl
   */
  public void setSgaUbicacionPosicion(SgaubicacionImpl value)
  {
    setAttributeInternal(SGAUBICACIONPOSICION, value);
  }


  /**
   * 
   *  Gets the associated entity SgaposicionubicacionImpl
   */
  public SgaposicionubicacionImpl getSgaposubides()
  {
    return (SgaposicionubicacionImpl)getAttributeInternal(SGAPOSUBIDES);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaposicionubicacionImpl
   */
  public void setSgaposubides(SgaposicionubicacionImpl value)
  {
    setAttributeInternal(SGAPOSUBIDES, value);
  }


  /**
   * 
   *  Gets the associated entity SgaposicionubicacionImpl
   */
  public SgaposicionubicacionImpl getSgaposubipos()
  {
    return (SgaposicionubicacionImpl)getAttributeInternal(SGAPOSUBIPOS);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaposicionubicacionImpl
   */
  public void setSgaposubipos(SgaposicionubicacionImpl value)
  {
    setAttributeInternal(SGAPOSUBIPOS, value);
  }
  
  /**
   * Reservar una cantidad para un ingreso de material o en una existencia
   * Si el mac no está ya reservado para salir al puesto, lo saca
   * existente, o bien creando una existencia nueva
   * Comprueba que el mac admite multireferencia, si fuera el caso
   * @param idart el artículo que se ingresará
   * @param canres  la cantidad a reservar
   * @return true si se ha podido reservar el material (y el mac), false si no
   * @param idUbiPuesto el puesto (ubicación) destino del mac
   */
  public boolean reservarEntradaMaterial(String idUbiPuesto, String idart, Number canres, int idTraslo)
  {
    if (admetNovaReferencia(idart) && quizasReservarMacSalida(idUbiPuesto, idTraslo))
    {
      // Si existe, añadir la reserva
      SgaexistenciaImpl  exist = null;
      exist = buscarExistencia (idart);    
      // Si no existeix, la creem (amb quantitat 0)
      if (exist == null)
      {
        SgaexistenciaDefImpl existencia = (SgaexistenciaDefImpl)SgaexistenciaImpl.getDefinitionObject();
        exist = existencia.crearExistencia(getDBTransaction(), getIdmac(), idart);
      }
      exist.reservarEntrada(canres);
      return true;
    }
    else
        return false;
  }
  
  /**
   * Reservar una cantidad para una salida de material
   * Si el mac no está ya reservado para salir al puesto, lo saca  
   * @return <code>true</code> si ha podido reservar el material (y el mac), <code>false</code> si no lo encuentra
   * @param canres  La cantidad a reservar
   * @param idart La identificación del artículo
   * @param idUbiPuesto  El puesto (ubicación) destino del mac
   */
  public boolean reservarSalidaMaterial(String idUbiPuesto, String idart, Number canres, int idTraslo)
  {
    if (!quizasReservarMacSalida(idUbiPuesto, idTraslo))
      return false;
    SgaexistenciaImpl exist = null;
    // Si existe, añadir la reserva
    exist = buscarExistencia (idart);
    if (exist != null)
    {
      exist.reservarEntrada(canres);
      
    }
    
    return exist != null;
  }
  
  
  public void cancelarReservaTrasllat()
  {
    RowIterator existencies = this.getSgaexistencia();
    existencies.reset();
    while (existencies.hasNext())
    {
      SgaexistenciaImpl exist = (SgaexistenciaImpl)existencies.next();
      if (exist.getEstado().equals("R"))
      {
        // Only reset if previous estado was "R"
        exist.setEstado("L");
      }
      
    }

    
  }
  
  public String getRotacion ()
  {
    char [] rotacion = {'C'};
    RowIterator existencies = this.getSgaexistencia();
    existencies.reset();
    while (existencies.hasNext())
    {
      SgaexistenciaImpl exist = (SgaexistenciaImpl)existencies.next();
      char r = exist.getRotacionExistencia().charAt(0);
      if (r < rotacion [0])
        rotacion [0] = r;
      
    }
    
    return (new String (rotacion));
    
  }

  /**
   * Buscar la existencia de una referencia. Sólo habrá una
   * @return la existencia, null si no se encuentra
   * @param idart
   */
  private SgaexistenciaImpl buscarExistencia (String idart)
  {
    boolean trobat = false;
    SgaexistenciaImpl  exist = null;
    RowIterator existencies = this.getSgaexistencia();
    existencies.reset();
    while (existencies.hasNext() && !trobat)
    {
      exist = (SgaexistenciaImpl)existencies.next();
      trobat = exist.getIdart().equals(idart);
    }
    return (trobat ? exist : null);
  }

  /**
   * Retorna cert si el mac ha quedat buit
   */
  private boolean macBuit ()
  {
    boolean buit = true;
    SgaexistenciaImpl  exist = null;
    RowIterator existencies = this.getSgaexistencia();
    if (existencies != null && existencies.getRowCount() > 0)
      buit = false;
    return (buit);
  }

  /**
   * Afegeix al mac la quantitat cantot de l'article idart.
   * Si no existeix un item per l'article, el crea.
   * @param cantot
   * @param idart
   */
   //TODO: Traspassar tota la informació necessaria en una estructura per crear
   // els històrics
  //public void afegirMaterial(String idart, Number cancon, Number canres)
  public void afegirMaterial(Sgamovexist movexist)
  {
    if (admetNovaReferencia(movexist.getIdart()))
    {
      // Si existeix, afegim cantot a l'existencia
      SgaexistenciaImpl  exist = null;
      exist = buscarExistencia (movexist.getIdart());    
      // Si no existeix, la creem (amb quantitat 0)
      if (exist == null)
      {
        SgaexistenciaDefImpl existencia = (SgaexistenciaDefImpl)SgaexistenciaImpl.getDefinitionObject();
        exist = existencia.crearExistencia(getDBTransaction(), getIdmac(), movexist.getIdart());
        
        if (movexist.getBloqueoExist() != null)
        {
          exist.setBloqueo(movexist.getBloqueoExist());
          exist.setMotivoBloqueo(movexist.getMotivoBloqueo());
        }
      }
      exist.afegirMaterial(movexist);
    }
    else
      throw new JboException(InterflexMessageBundle.class,
                             InterflexMessageBundle.MAC_AMB_EXISTENCIES,
                             new Object[] {getIdmac()});
  }



  /**
   * Treu del mac la quantitat cantot de l'article idart.
   * @param cantot
   * @param idart
   */
   //TODO: Traspassar tota la informació necessaria en una estructura per crear
   // els històrics
  public void treureMaterial(Sgamovexist movexist)
  {
      SgaexistenciaImpl  exist = null;
      exist = buscarExistencia(movexist.getIdart());
      // Si hi ha proutes existències, deixem treure el material
      if (exist != null)
      {
        exist.treureMaterial(movexist);
        // Aqui s'hauria de verificar si el mac s'ha quedat buit, i recollir la 
        // tara
        if (macBuit())
        {
          // Michael 12.01.2007 Si la tara varía en más de 50% del teórico, no lo ponemos
          int compareResult;
          Number taraStandard = getSgatipomac().getTara();
          Number taraActual = movexist.getPesfin();
            // Michael 14.05.2008 Sólo hacer si tenemos tara actual
          if (taraActual != null)
          {
            if (taraStandard != null  && taraStandard.compareTo(0) > 0)
            {
              NUMBER diff = taraStandard.subtract(taraActual).abs();
              NUMBER tara5 = taraStandard.divide(20);
              // Returns -1 if NUMBER is less than n, 0 if NUMBER and n are equal (==), 1 if NUMBER is greater than n
              compareResult = diff.compareTo(tara5);
              // Michael 19.01.2009 Debugging appears to pass into the next block, but in actual fact it is 
              // i  nterpreting it correctly.
              if (compareResult < 0)
              {
                  setTara(taraActual);
              }
            }
            else
              if (taraActual != null)
                setTara(taraActual);
            // Michael 12.01.2007 Fin          
          } // Michael 14.05.2008
        }
      }
      else
        throw new JboException(InterflexMessageBundle.class,
                               InterflexMessageBundle.MAC_SENSE_EXISTENCIES,
                               new Object[] {getIdmac(), movexist.getIdart()});
  }


  /**
   * Anula una entrada de material al mac.
   * Si no existeix un item per l'article, el crea.
   * @param cantot
   * @param idart
   */
   //TODO: Traspassar tota la informació necessaria en una estructura per crear
   // els històrics
  public void anularAfegirMaterial(String idart, Number canres)
  {
      SgaexistenciaImpl  exist = null;
      exist = buscarExistencia (idart);    
      if (exist != null)
        exist.anularAfegirMaterial(canres);
  }

  /**
   * Anular las reservas que pudiera tener el mac
   */
  public void anularReservas()
  {
    RowIterator resRows = getSgaresmatMany();
    resRows.reset();
    while (resRows.hasNext())
    {
      SgaresmatImpl row = (SgaresmatImpl)resRows.next();
      // No s'anul·la el pendent
      row.anularReserva(false);    
    }
  }

  /**
   * Tratar un error de extracción del MAC
   * Anular las reservas del MAC
   * Ponerlo de nuevo en donde ha salido
   * Dejar el mac en estado libre
   * Marcar la posición del hueco como pendiente de inspección
   */
  public void setErrorExtraccion()
  {
    anularReservas();
    setUbides(getUbipos());
    setPosubides(getPosubipos());
    setEstado("L"); 
    getSgaUbicacionPosicion().setPendienteInspeccion(getSgaposubipos(), getNumpos());
  }
  
  /**
   * Tratar un error de depósito del MAC
   * Marca el hueco actual pendiente de extracción
   * Busca un hueco alternativo para el mac en el mismo pasillo
   * Si no hay hueco alternativa, saca el mac a un puesto
   */
  public void setErrorDeposito()
  {
    // Actualiza a la posición actual
    setUbipos(getUbides());
    setPosubipos(getPosubides());
    
    getSgaUbicacionDestino().setPendienteInspeccion(getSgaposubides(), getNumpos());
    SgaposicionubicacionImpl pos = getSgaUbicacionDestino().getPosicionUbicacionErrorDeposito(getIdtipmac(), getSgaposubides());
    if (pos != null)
    {
      
      setUbides(pos.getIdubi());
      setPosubides(pos.getPosicion());
      
    }
    else
    {
      // Buscar de sacarlo a un puesto....
      setEstado("R"); // Para que se vea en el puesto
      if (isMiniload())
        setUbides(SgaubicacionImpl.PK1MLD);
      else
        setUbides(SgaubicacionImpl.PK1SLO);
    }
    

  }
  
  /**
   * Anula una sortida de material del mac
   * @param cantot
   * @param idart
   */
   //TODO: Traspassar tota la informació necessaria en una estructura per crear
   // els històrics
  public void anularTreureMaterial(String idart, Number canres)
  {
      SgaexistenciaImpl  exist = null;
      exist = buscarExistencia(idart);
      // Si hi ha proutes existències, deixem treure el material
      if (exist != null)
        exist.anularTreureMaterial(canres);
  }

  /**
   * 
   *  Add attribute defaulting logic in this method.
   */
  protected void create(AttributeList attributeList)
  {
    super.create(attributeList);
    
    // Michael 14.05.2008 doesn't work when carga nova because idmac is not yet informed
    // Michael 09.03.2006 Recuperar la tara si existe
    SgamactaraImpl macTara = getSgamactara();
    if (macTara != null)
    {
      setTara(macTara.getTara());
    }


      
    setMultiref("N");
  }
  



  public void evacuarMac()
  {
    setEstado("P");
  }


  /**
   * 
   *  Gets the associated entity SgaresmatImpl
   */
  public SgaresmatImpl getSgaresmat()
  {
    return (SgaresmatImpl)getAttributeInternal(SGARESMAT);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgaresmatImpl
   */
  public void setSgaresmat(SgaresmatImpl value)
  {
    setAttributeInternal(SGARESMAT, value);
  }


  /**
   * Indica si el contenidor admet una nova existencia de la
   * referencia idart
   */
  private boolean admetNovaReferencia(String idart)
  {
    boolean afegir = true;
    // Si es multireferencia o no te cap existencia, deixem afegir
    if (getMultiref().equals("S") || getSgaexistencia().getRowCount() == 0)
      return true;
    else
    {
      RowIterator exists = getSgaexistencia();
      exists.reset();
      while (exists.hasNext() && afegir)
      {
        SgaexistenciaImpl exist = (SgaexistenciaImpl)exists.next();
        if (!exist.getIdart().equals(idart) && exist.getCantot().compareTo(0) > 0)
          afegir = false;
      }
      return afegir;
    }
  }



  public void setEnUbicacion()
  {
    setEstado("L");
  }

  public void reservarMac()
  {
    setEstado("R");
  }

  public void setEnPuesto()
  {
    setEstado("P");
  }

  public void setPendienteEvacuacion()
  {
    setEstado("X");
  }


  /**
   * 
   * @return <code>true</code> si la posición requiere un movi para avanzar
   */
  public boolean isMoviPosicionAvis()
  {
    int posPlc = getSgaUbicacionPosicion().getPosplc().intValue();
    // :TODOswitch (posPlc
    switch (posPlc)
    {
      case SgaubicacionImpl.POSPLC_GALIBO_44:
      case SgaubicacionImpl.POSPLC_GALIBO_6:
        return true;
      default:
        return false;
    }
  }
  
    /**
   * 
   * @return <code>true</code> si la posición requiere un movi para avanzar
   */
  public boolean isMoviPosicionPeti()
  {
    int posPlc = getSgaUbicacionPosicion().getPosplc().intValue();
    switch (posPlc)
    {
      case SgaubicacionImpl.POSPLC_9:
      case SgaubicacionImpl.POSPLC_27:
      case SgaubicacionImpl.POSPLC_32:
      case SgaubicacionImpl.POSPLC_37:
      case SgaubicacionImpl.POSPLC_42:
        return true;
      default:
        return false;
    }
  }
  
  public boolean is44destino45()
  {
    return (getSgaUbicacionPosicion().is44() && getSgaUbicacionDestino().is45());
    
  }
  
  
  
  public boolean is27()
  {
    return (getSgaUbicacionPosicion().is27());
    
  }
  
  public boolean is6o44()
  {
    return (getSgaUbicacionPosicion().is6o44());
  }

  public boolean is6()
  {
    return (getSgaUbicacionPosicion().is6());
  }

  public boolean is45()
  {
    return (getSgaUbicacionPosicion().is45());
  }
  
  public boolean isDestino45()
  {
    return (getSgaUbicacionDestino().is45());
  }
  
  public boolean isPosPlc(int posPlc)
  {
    return (getSgaUbicacionPosicion().isPosPlc(posPlc));
  }
  
 
  /**
   * Actualizar el mac como llegado al destino que le corresponde
   * @see #setPosubipos 
   */
  public void setLlegadoDestino()
  {
    setUbipos(getUbides());
    setPosubipos(getPosubides());
  }
 
  /**
   * Deshacer una orden de movimiento, poniendo el mac en su posición original, o donde este
   * TODO: Deshacer cuales reservas pudiera tener el mac
   * @param inspeccionarUbicacion
   * TODO: Si la posición no es una posición final de la orden, no actualizarla ya que no hay
   *  que hacer con el MAC entonces
   */
  public void resetOrdtran(boolean inspeccionarUbicacion)
  {
  
    setPosubides(null);
    setUbides (getUbipos());
    setPosubides(getPosubipos());
    SgaresmatImpl resmat = getSgaresmat();
    if (resmat != null)
      // No s'anul.la el pendent
      resmat.anularReserva(false);
    setEstado("L");
    
    System.out.println("Pendiente bloquear la ubicación: " + inspeccionarUbicacion);
  }


  /**
   * 
   *  Add entity remove logic in this method.
   */
  public void remove()
  {
    // Anular reservas
    anularReservas();
    // Borrar las existencias si hubiera
    RowIterator existRows = getSgaexistencia();
    existRows.reset();
    while (existRows.hasNext()) 
    {
      SgaexistenciaImpl existRow = (SgaexistenciaImpl)existRows.next();
      existRow.treureTot();
    }
    // "Desocupar la posicion, destino
    // NOTA: Hacer después de treure tot ya que la ubipos se inserta en el histórico
    setUbipos(null);
    setUbides(null);
    
    
    // Michael 16.12.2005 Borra cualquier orden de transporte que pudiera tenir
    
    SgaordtranImpl ordTran = getSgaordtran();
    if (ordTran != null)
    {
      ordTran.setEstado("B"); // Para que sea enviado al PLC para su borrado TODO 16.12.2005 Ver que lo borre del todo
    }
    
    // Michael 09.03.2006
    // Si ya existe registro del mac en mactara, actualizar la tara actual
    // Si no, insertar registro con la tara actual del mac
    // Si el mac no tiene tara, no vale la pena guardar los datos
    if (getTara() != null)
    {
      SgamactaraImpl macTara = getSgamactara();
      if (macTara != null)
      {
        macTara.setTara(getTara());
      }
      else
      {
        SgamactaraDefImpl macTaraDef = (SgamactaraDefImpl)SgamactaraImpl.getDefinitionObject();
        macTaraDef.createInstance(getDBTransaction(), getIdmac(), getIdtipmac(), getTara());
      }
    }
    
    super.remove();
  }


  /**
   * 
   *  Gets the associated entity oracle.jbo.RowIterator
   */
  public RowIterator getSgaresmatMany()
  {
    return (RowIterator)getAttributeInternal(SGARESMATMANY);
  }


  private Number getTaraAll()
  {
    Number tara = getTara();
    if (tara == null)
      tara = getSgatipomac().getTara();
    return tara;
  }
  /**
   * 
   *  Gets the attribute value for Tara, using the alias name Tara
   */
  public Number getTara()
  {
    return (Number)getAttributeInternal(TARA);
  }

  /**
   * 
   *  Sets <code>value</code> as the attribute value for Tara
   */
  public void setTara(Number value)
  {
    setAttributeInternal(TARA, value);
  }



  public void getDisponibilitat(Vector disponibilitat)
  {
    // La ubicació i destí han de coincidir 
    if (!(getUbipos() != null && getUbides() != null && getUbipos().equals(getUbides())))
      disponibilitat.addElement(getEntityDef().getProperty("UBICACIO_DESTI_DIFERENTS"));
    //La posició dins la ubicació ha de coincidir amb la de destí (si en te)
    if (getPosubipos() != null)
    {
      if (!(getPosubides() != null && getPosubipos().equals(getPosubides())))
        disponibilitat.addElement(getEntityDef().getProperty("POSICIO_DESTI_DIFERENTS"));
    }    
    // L'estat ha de ser Lliure (L)
    if (!(getEstado() != null && getEstado().equals("L")))
      disponibilitat.addElement(getEntityDef().getProperty("MAC_NO_DISPONIBLE"));
      
    // Verifiquem la disponibiligetSgaposubipos()tat de la ubicació  
    getSgaUbicacionPosicion().getDisponibilitat(getSgaposubipos(), disponibilitat);
    
  }
  
  private boolean isMultiRef()
  {
    return (getMultiref() != null && getMultiref().equals("S"));
  }

  /**
   * 
   * @return el peso del mac más sus existencias, 0 si no se puede calcular
   * Si es multireferencia, no se controla por peso
   * Si no tiene existencias, no se controla el peso
   */
  public Number getPesTeoric()
  {
    if (isMultiRef())
      return (new Number(0));

    SgaexistenciaImpl exist = getFirstExistencia();
    
    if (exist == null)
      return (new Number(0));
      
    Number pesExist;
    if (exist.isControladaPerPes())
      pesExist = exist.getPesTeoric(exist.getCantot());
    else
      return (new Number(0));
    
    return new Number(pesExist.add(getTaraAll()).round(2));

  }
  
  public SgaexistenciaImpl getFirstExistencia() 
  {
    SgaexistenciaImpl  exist = null;
    RowIterator existencies = getSgaexistencia();
    existencies.reset();
    exist = (SgaexistenciaImpl)existencies.first();
    return exist;
  }
  
  
  public Number getCantitatSegonsPes(Number pes)
  {
    SgaexistenciaImpl  exist = getFirstExistencia();
    if (exist == null)
      return (new Number(0));
    else
      return exist.getCantitatSegonsPes(pes);
  }
  
  
  public boolean isControladaPerPes()
  {
    if (isMultiRef())
      return false;
      
    SgaexistenciaImpl exist = getFirstExistencia();  
    if (exist == null)
      return false;
    
    return exist.isControladaPerPes();      
      
  }
  
  
  /**
   * Devolver la cantidad según un peso (bruto)
   * @return 
   * @param pes
   */
  public Number getCantotPerPes(Number pes)
  {
    Number cantot;
    Number pesNet = pes.subtract(getTaraAll());
    if (pesNet.compareTo(new Number(0)) > 0)
    {
      cantot = new Number(getCantitatSegonsPes(pesNet).round(0));
    }
    else
      cantot = new Number(0);

    return cantot;
  }
  
  
  

  /**
   * 
   *  Gets the associated entity SgamactaraImpl
   */
  public SgamactaraImpl getSgamactara()
  {
    return (SgamactaraImpl)getAttributeInternal(SGAMACTARA);
  }

  /**
   * 
   *  Sets <code>value</code> as the associated entity SgamactaraImpl
   */
  public void setSgamactara(SgamactaraImpl value)
  {
    setAttributeInternal(SGAMACTARA, value);
  }

  /**
   * 
   *  Creates a Key object based on given key constituents
   */
  public static Key createPrimaryKey(String idmac)
  {
    return new Key(new Object[] {idmac});
  }










































































}